<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Java]Spring Security 인증(Authentication)과 인가(Authorization) | 봄을 기다리는 낙엽</title>
<meta name=keywords content="authentication,authorization"><meta name=description content="Spring Security의 인가 로직에 대해 알아봅니다."><meta name=author content="Leaf"><link rel=canonical href=https://1eaf.site/posts/spring_security/3/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://1eaf.site/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://1eaf.site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://1eaf.site/favicon-32x32.png><link rel=apple-touch-icon href=https://1eaf.site/apple-touch-icon.png><link rel=mask-icon href=https://1eaf.site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://1eaf.site/posts/spring_security/3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://1eaf.site/posts/spring_security/3/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="[Java]Spring Security 인증(Authentication)과 인가(Authorization)"><meta property="og:description" content="Spring Security의 인가 로직에 대해 알아봅니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-29T12:24:33+09:00"><meta property="article:modified_time" content="2024-11-29T12:24:33+09:00"><meta property="article:tag" content="Authentication"><meta property="article:tag" content="Authorization"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Java]Spring Security 인증(Authentication)과 인가(Authorization)"><meta name=twitter:description content="Spring Security의 인가 로직에 대해 알아봅니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://1eaf.site/posts/"},{"@type":"ListItem","position":2,"name":"Spring Security 파헤치기","item":"https://1eaf.site/posts/spring_security/"},{"@type":"ListItem","position":3,"name":"[Java]Spring Security 인증(Authentication)과 인가(Authorization)","item":"https://1eaf.site/posts/spring_security/3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Java]Spring Security 인증(Authentication)과 인가(Authorization)","name":"[Java]Spring Security 인증(Authentication)과 인가(Authorization)","description":"Spring Security의 인가 로직에 대해 알아봅니다.","keywords":["authentication","authorization"],"articleBody":"도입 지난 포스팅 [Java]Spring Security WebMVC 기본 구조 [Java]Spring Security 예외처리, 캐싱, 로깅 Spring Security의 WebMVC와 기타 기능들에 이어 다양한 기능을 지원하는 인가 로직에 대해 알아보겠습니다.\n이전의 포스팅들과 이번 포스팅까지 제대로 이해한다면, 기본적인 Spring Security의 기능들을 사용하는데 큰 어려움이 없으실 겁니다.\n인증과 인가 너무 추상적이지만 Spring Security를 이해하는데 중요한 개념이므로 짚고 넘어가겠습니다.\n인증(Authentication) : 데이터나 시스템의 접근 권한을 가졌는지 검증하는 것입니다. 인가(Authorization) : 특정 리소스의 접근 권한을 가졌는지 확인하여 허용 또는 거부하는 것입니다. 즉, 인증은 로그인하는 행위 그 자체인 반면, 인가는 로그인한 사용자의 권한을 확인해서 접근 제어를 하는 것입니다.\n둘은 유사해 보이지만, 인증 오류(401)와 인가 오류(403)가 구분되어 있는 것처럼 보안에서 두 개념을 분리해서 생각하는 것은 중요합니다.1\n인증과 인가 : 인증된 사용자인지 먼저 확인하고, 이후 권한을 확인합니다.\nAuthentication 인증은 Spring Security의 핵심 로직입니다.\n인증이 성공하면, 사용자의 자격을 확인하고, 권한을 부여합니다. 인증이 실패하면, 실패 메시지를 전송하거나 인증 URL로 Redirect를 하는 등의 작업을 수행합니다. SecurityContext 현재 요청(사용자)의 인증 객체(Authentication)를 담고 있는 문맥, 혹은 컨테이너입니다. 인증이 완료된 인증 객체를 저장하는 역할을 합니다.\n이러한 Context는 쓰레드 로컬 저장소인 SecurityContextHolder 내부에 위치하고 있습니다.2 Authentication Object 사용자 식별자, 증명, 권한 등의 인증 정보를 담고 있는 객체입니다. 인증된 객체는 SecurityContext에 담아 요청 전역에서 사용할 수 있습니다.\nprincipal : 사용자 식별자입니다. 사용자를 구분할 수 있는 고유한 값이 필요합니다. credentials : 비밀번호와 같은 증명입니다. 인증이 완료된 이후 외부 노출을 막기 위해 초기화됩니다. authorities : 해당 사용자의 인증과 동시에 승인되는 권한입니다. 인가를 설명하면서 더 자세히 살펴보겠습니다. 인증된 객체는 ThreadLocal 내부에 저장되어 요청 전역에 사용됩니다.\nAuthenticationManager 인증을 관리하기 위한 인터페이스(API)입니다. Spring Security는 해당 인터페이스를 사용해서 인증을 수행하기 때문에 이를 구현해야 활용할 수 있습니다.\n만약 Spring Security를 사용하지 않고 Filter에서 직접 SecurityContext에 접근한다면 구현할 필요는 없습니다.\n다만, Spring Security에서 제공하는 다양한 캐싱과 로깅, 최적화 등의 기능을 잘 활용하려면 이를 구현하는게 좋습니다.\nProviderManager\nAuthenticationManager를 구현한 구현체입니다. 인증 서비스를 제공하는 AuthenticationProvider들을 리스트로 담아서 관리하며 인증 필요 시 사용자 요청에서 Id, Password, Token등을 확인하여 인증을 시도합니다.\n만약 AuthenticationProvider가 등록되지 않은 상태로 ProviderManager를 사용한다면 인증 관련 오류인 ProviderNotFoundException이 발생합니다.\nAuthenticationProvider\n인증을 제공하는 객체입니다. ProviderManager에 등록되어 순서대로 실행됩니다.\n기본적으로 AuthenticationProvider는 증명(credentials)을 외부에 노출하지 않기 위해 인증과 동시에 비우게 됩니다.3 인증 제공자(AuthenticationProvider)는 단순한 Username, Password 뿐 아니라, OTT, Anonymous 등 다양한 방식의 인증을 제공합니다. 인증 제공자들에 대한 자세한 설명은 공식 문서를 참고하시기 바랍니다.\n인증 관리자는 인증 제공자들을 리스트로 가지며, 인증 여부 확인을 위임하여 다양한 인증 수단을 활용합니다.\nAbstractAuthenticationProcessingFilter 인증의 주요 흐름을 담고 있는 필터입니다. ExceptionTranslationFilter에서 이미 살펴보았던 AuthenticationEntryPoint를 통해 받은 요청에서 사용자 정보(principals) 및 증명(credentials)을 가져와서 인증을 시도합니다.\n인증 필터의 주요 흐름\n인증 오류를 처리한다는 점에서 ExceptionTranslationFilter와 동작이 유사합니다. 다만, 내부적으로 발생할 수 있는 오류들을 Try-Catch로 잡아서 처리하기 때문에 인증 과정에서 실패하더라도 ExceptionTranslationFilter까지 도달하지 않고 설정된 AuthenticationFailureHandler를 사용합니다.4\nAuthorization 인증된 객체는 권한을 인가받게 되는데, 권한에 따라 자원(URL) 별로 접근제어가 가능합니다.\nAuthorities 위에서 설명한 것처럼, 인증 객체는 생성과 동시에 권한(authorities)을 리스트로 갖게 됩니다.\n승인된 권한이라는 뜻에서 GrantedAuthority라는 클래스의 객체로 저장됩니다.5 AuthorizationManager 인가를 관리하기 위한 인터페이스(API)입니다. AuthorizationManager는 승인된 권한을 바탕으로, 접근을 허용할지 아니면 거부할지를 결정합니다.\n내부적으로 다음과 같이 구현되어, 구현된 check 메서드를 default 메서드인 verify에서 위임하여 실행하는 식으로 동작합니다.\nAuthorizationDecision check(Supplier\u003cAuthentication\u003e authentication, Object secureObject); default void verify(Supplier\u003cAuthentication\u003e authentication, Object secureObject) throws AccessDeniedException { // ... } check\n해당 요청을 승인할지, 거부할지를 결정합니다. 승인 : new AuthorizationDecision(true)를 반환합니다. 요청을 정상적으로 진행합니다. 거부 : new AuthorizationDecision(false)를 반환합니다. AccessDeniedException 예외가 발생합니다. 이러한 API를 구현한 다양한 구현체가 있으며, 어플리케이션의 특성에 맞게 접근권한을 관리하는 것이 가능합니다.\n자세한 구현체들은 공식 문서에서 확인할 수 있으니, 본인의 상황에 맞는 구현체를 선택하거나, 필요 시 커스터마이징 하여 사용하시면 됩니다.\n인가 관리자 구현체(Spring Security Reference Doc)\n계층적 역할(Hierarchical Roles) 대부분의 어플리케이션에서 역할6은 특정한 계층을 가지고 있습니다.\n예를 들어, 관리자 권한은 사용자가 가진 모든 권한을 사용 가능하고 거기에 추가로 관리자의 권한이 더해지는 식입니다. 그러나 이러한 계층적 권한은 어플리케이션을 복잡하게 만들 수 있습니다. 전체 관리자와 중간 관리자, 사용자 세가지 권한이 있다고 하면 사용자의 권한을 중간관리자는 모두 가져야 하고, 전체 관리자는 중간 관리자와 사용자 관리자의 권한을 모두 가져야 하는 복잡한 상황이 발생합니다.\n이를 쉽게 구현하기 위해, Spring Security는 계층적으로 권한을 관리할 수 있는 API를 제공합니다. @Bean static RoleHierarchy roleHierarchy() { return RoleHierarchyImpl.withDefaultRolePrefix() .role(\"ADMIN\").implies(\"STAFF\") .role(\"STAFF\").implies(\"USER\") .role(\"USER\").implies(\"GUEST\") .build(); } @Bean static MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) { DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler(); expressionHandler.setRoleHierarchy(roleHierarchy); return expressionHandler; } 위와 같이 설정하게 되면, ADMIN 계정은 STAFF, USER, GUEST 권한 목록을 갖고, STAFF 계정은 USER, GUEST 권한 목록을 갖고, USER 계정은 GUEST 권한 목록을 갖게 됩니다. 물론 위 설정에서처럼 MethodSecurityExpressionHandler를 통해 설정된 권한 계층을 AuthorizationManager에서 사용하지 않으면 적용되지 않습니다.\n역할 계층 구조도[ADMIN \u003e STAFF \u003e USER \u003e GUEST] : 하위 계층의 권한을 상위 계층이 기본적으로 포함하고 있습니다.\n결론 Spring Security의 로직은 다음 API를 구현하여 활용할 수 있습니다.\n인증(Authentication) : AuthenticationManager 인가(Authorization) : AuthorizationManager 다음 포스팅에서는 Spring Security를 활용하여 TDD7 스타일로 인증 및 인가 로직을 개발해보겠습니다.\n다음 포스팅 [Java]Spring Security(With TDD) 기본 인증 및 인가 구현하기 References URL 게시일자 방문일자 작성자 인증(Authorization) 2024.11.22. 2024.11.29. Wikipedia 인가(Authentication) 2024.11.6. 2024.11.29. Wikipedia Understanding 403 Forbidden 2011.7.18. 2024.11.29. Daniel Irvine Spring Security Authentication - 2024.11.29. Spring Spring Security Authorization - 2024.12.02. Spring 401은 인증 오류이지만, 영문명은 Unauthorized입니다. 이러한 개념을 이해하기 좋은 문서가 있어 첨부합니다. ↩︎\nSecurityContext는 사용자 요청별로 관리되어야 하기 때문에 Thread-Safety하도록 ThreadLocal 저장소에 보관됩니다.\nThread-Safety가 보장되지 않는다면 현재 사용자가 아닌 다른 사용자의 인증 객체에 접근할 가능성이 있어 보안 이슈가 발생할 수 있습니다.\n↩︎ 만약 사용자 요청을 캐싱하여 반환할 경우, 증명(Credentials)이 지워진 상태로 저장될 수 있습니다. 따라서 캐싱된 요청을 다시 인증하는게 불가능하기 때문에 별도의 인증 로직을 구성하거나 이러한 옵션을 해제해야 합니다.\n캐싱된 인증은 자격증명이 삭제된 상태로 저장될 수 있습니다.\n↩︎\n실제로 디버깅을 통해 로그인 요청이 실패하여 재로그인 시도 시 ExceptionTranslationFilter의 AuthenticationEntryPoint로 이동하지 않고, AbstractAuthenticationProcessingFilter내부의 AuthenticationFailureHandler를 사용하여 로그인 페이지로 Redirect 하는 것을 확인할 수 있었습니다. ↩︎\nGrantedAuthority객체는 기본적으로 SimpleGrantedAuthority 구현체를 사용할 수 있는데, 권한 요청 메서드인 getAuthority()를 실행했을 때 ROLE_형태의 Prefix를 가지는 권한(String)을 가져올 수 있습니다.\n이러한 권한 객체의 Prefix는 다음과 같이 변경해서 사용할 수 있습니다.\n@Bean static GrantedAuthorityDefaults grantedAuthorityDefaults() { return new GrantedAuthorityDefaults(\"MYPREFIX_\"); } ↩︎ 역할은 권한들의 집합입니다.\n예를 들어, 사용자 역할(ROLE_USER) 은 다음과 같이 로그인, 게시글 조회, 본인 게시글 수정, 본인 게시글 삭제 의 권한을 가질 수 있습니다.\nROLE_USER = {LOGIN_AUTHORITY, GET_POST_AUTHORITY, PATCH_MY_POST_AUTHORITY, DELETE_MY_POST_AUTHORITY}\n↩︎ Test Driven Development의 준말로, 단위 테스트를 먼저 작성한 후 구현하는 방식의 개발 방법론입니다. ↩︎\n","wordCount":"970","inLanguage":"ko","datePublished":"2024-11-29T12:24:33+09:00","dateModified":"2024-11-29T12:24:33+09:00","author":{"@type":"Person","name":"Leaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://1eaf.site/posts/spring_security/3/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"https://1eaf.site/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://1eaf.site/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://1eaf.site/search/ title=검색><span>검색</span></a></li><li><a href=https://1eaf.site/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://1eaf.site/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://1eaf.site/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://1eaf.site/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://1eaf.site/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://1eaf.site/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://1eaf.site/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://1eaf.site/>홈</a>&nbsp;»&nbsp;<a href=https://1eaf.site/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://1eaf.site/posts/spring_security/>Spring Security 파헤치기</a></div><h1 class="post-title entry-hint-parent">[Java]Spring Security 인증(Authentication)과 인가(Authorization)</h1><div class=post-description>Spring Security의 인가 로직에 대해 알아봅니다.</div><div class=post-meta><span title='2024-11-29 12:24:33 +0900 KST'>2024. 11. 29.</span>&nbsp;·&nbsp;5 분&nbsp;·&nbsp;970 단어&nbsp;·&nbsp;Leaf&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content/ rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#도입>도입</a><ul><li><a href=#지난-포스팅>지난 포스팅</a></li></ul></li><li><a href=#인증과-인가>인증과 인가</a></li><li><a href=#authentication>Authentication</a><ul><li><a href=#securitycontext>SecurityContext</a></li><li><a href=#authentication-object>Authentication Object</a></li><li><a href=#authenticationmanager>AuthenticationManager</a></li><li><a href=#abstractauthenticationprocessingfilter>AbstractAuthenticationProcessingFilter</a></li></ul></li><li><a href=#authorization>Authorization</a><ul><li><a href=#authorities>Authorities</a></li><li><a href=#authorizationmanager>AuthorizationManager</a></li><li><a href=#계층적-역할hierarchical-roles>계층적 역할(Hierarchical Roles)</a></li></ul></li><li><a href=#결론>결론</a><ul><li><a href=#다음-포스팅>다음 포스팅</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=도입>도입<a hidden class=anchor aria-hidden=true href=#도입>#</a></h2><h3 id=지난-포스팅>지난 포스팅<a hidden class=anchor aria-hidden=true href=#지난-포스팅>#</a></h3><ul><li><a href=https://leaf-nam.github.io/posts/spring_security/1>[Java]Spring Security WebMVC 기본 구조</a></li><li><a href=https://leaf-nam.github.io/posts/spring_security/2>[Java]Spring Security 예외처리, 캐싱, 로깅</a></li></ul><p>Spring Security의 WebMVC와 기타 기능들에 이어 다양한 기능을 지원하는 인가 로직에 대해 알아보겠습니다.</p><blockquote><p>이전의 포스팅들과 이번 포스팅까지 제대로 이해한다면, 기본적인 Spring Security의 기능들을 사용하는데 큰 어려움이 없으실 겁니다.</p></blockquote><h2 id=인증과-인가>인증과 인가<a hidden class=anchor aria-hidden=true href=#인증과-인가>#</a></h2><p>너무 추상적이지만 Spring Security를 이해하는데 중요한 개념이므로 짚고 넘어가겠습니다.</p><ul><li><a href=https://en.wikipedia.org/wiki/Authentication>인증(Authentication)</a> : 데이터나 시스템의 접근 권한을 가졌는지 검증하는 것입니다.</li><li><a href=https://en.wikipedia.org/wiki/Authorization>인가(Authorization)</a> : 특정 리소스의 접근 권한을 가졌는지 확인하여 허용 또는 거부하는 것입니다.</li></ul><p>즉, 인증은 로그인하는 행위 그 자체인 반면, 인가는 로그인한 사용자의 권한을 확인해서 접근 제어를 하는 것입니다.</p><blockquote><p>둘은 유사해 보이지만, 인증 오류(401)와 인가 오류(403)가 구분되어 있는 것처럼 보안에서 두 개념을 분리해서 생각하는 것은 중요합니다.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><figure><img loading=lazy src=auth.png alt="인증과 인가 : 인증된 사용자인지 먼저 확인하고, 이후 권한을 확인합니다."><figcaption><p>인증과 인가 : 인증된 사용자인지 먼저 확인하고, 이후 권한을 확인합니다.</p></figcaption></figure><h2 id=authentication>Authentication<a hidden class=anchor aria-hidden=true href=#authentication>#</a></h2><p>인증은 Spring Security의 핵심 로직입니다.</p><ul><li>인증이 성공하면, 사용자의 자격을 확인하고, 권한을 부여합니다.</li><li>인증이 실패하면, 실패 메시지를 전송하거나 인증 URL로 Redirect를 하는 등의 작업을 수행합니다.</li></ul><h3 id=securitycontext>SecurityContext<a hidden class=anchor aria-hidden=true href=#securitycontext>#</a></h3><p>현재 요청(사용자)의 인증 객체(Authentication)를 담고 있는 문맥, 혹은 컨테이너입니다. 인증이 완료된 인증 객체를 저장하는 역할을 합니다.</p><ul><li>이러한 Context는 쓰레드 로컬 저장소인 <code>SecurityContextHolder</code> 내부에 위치하고 있습니다.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li></ul><h3 id=authentication-object>Authentication Object<a hidden class=anchor aria-hidden=true href=#authentication-object>#</a></h3><p>사용자 식별자, 증명, 권한 등의 인증 정보를 담고 있는 객체입니다. 인증된 객체는 <code>SecurityContext</code>에 담아 요청 전역에서 사용할 수 있습니다.</p><ul><li><strong>principal</strong> : 사용자 식별자입니다. 사용자를 구분할 수 있는 고유한 값이 필요합니다.</li><li><strong>credentials</strong> : 비밀번호와 같은 증명입니다. 인증이 완료된 이후 외부 노출을 막기 위해 초기화됩니다.</li><li><strong>authorities</strong> : 해당 사용자의 인증과 동시에 승인되는 권한입니다. <a href=#authorization>인가</a>를 설명하면서 더 자세히 살펴보겠습니다.</li></ul><figure><img loading=lazy src=security_context.png alt="인증된 객체는 ThreadLocal 내부에 저장되어 요청 전역에 사용됩니다."><figcaption><p>인증된 객체는 ThreadLocal 내부에 저장되어 요청 전역에 사용됩니다.</p></figcaption></figure><h3 id=authenticationmanager>AuthenticationManager<a hidden class=anchor aria-hidden=true href=#authenticationmanager>#</a></h3><p>인증을 관리하기 위한 인터페이스(API)입니다. Spring Security는 해당 인터페이스를 사용해서 인증을 수행하기 때문에 이를 구현해야 활용할 수 있습니다.</p><ul><li><p>만약 Spring Security를 사용하지 않고 <code>Filter</code>에서 직접 <code>SecurityContext</code>에 접근한다면 구현할 필요는 없습니다.</p><blockquote><p>다만, Spring Security에서 제공하는 다양한 캐싱과 로깅, 최적화 등의 기능을 잘 활용하려면 이를 구현하는게 좋습니다.</p></blockquote></li><li><p><strong>ProviderManager</strong></p><p><code>AuthenticationManager</code>를 구현한 구현체입니다. 인증 서비스를 제공하는 <code>AuthenticationProvider</code>들을 리스트로 담아서 관리하며 인증 필요 시 사용자 요청에서 Id, Password, Token등을 확인하여 인증을 시도합니다.</p><ul><li><p>만약 <code>AuthenticationProvider</code>가 등록되지 않은 상태로 <code>ProviderManager</code>를 사용한다면 인증 관련 오류인 <code>ProviderNotFoundException</code>이 발생합니다.</p></li><li><p><strong>AuthenticationProvider</strong></p><p>인증을 제공하는 객체입니다. <code>ProviderManager</code>에 등록되어 순서대로 실행됩니다.</p><ul><li>기본적으로 <code>AuthenticationProvider</code>는 증명(credentials)을 외부에 노출하지 않기 위해 인증과 동시에 비우게 됩니다.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ul></li></ul><blockquote><p>인증 제공자(<code>AuthenticationProvider</code>)는 단순한 Username, Password 뿐 아니라, OTT, Anonymous 등 다양한 방식의 인증을 제공합니다. 인증 제공자들에 대한 자세한 설명은 <a href=https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/index.html>공식 문서</a>를 참고하시기 바랍니다.</p></blockquote></li></ul><figure><img loading=lazy src=authentication_manager.png alt="인증 관리자는 인증 제공자들을 리스트로 가지며, 인증 여부 확인을 위임하여 다양한 인증 수단을 활용합니다."><figcaption><p>인증 관리자는 인증 제공자들을 리스트로 가지며, 인증 여부 확인을 위임하여 다양한 인증 수단을 활용합니다.</p></figcaption></figure><h3 id=abstractauthenticationprocessingfilter>AbstractAuthenticationProcessingFilter<a hidden class=anchor aria-hidden=true href=#abstractauthenticationprocessingfilter>#</a></h3><p>인증의 주요 흐름을 담고 있는 필터입니다. <a href=https://leaf-nam.github.io/posts/spring_security/2/#exceptiontranslationfilter>ExceptionTranslationFilter</a>에서 이미 살펴보았던 <code>AuthenticationEntryPoint</code>를 통해 받은 요청에서 사용자 정보(principals) 및 증명(credentials)을 가져와서 인증을 시도합니다.</p><figure><img loading=lazy src=abstractAuthenticationProcessingFilter.png alt="인증 필터의 주요 흐름"><figcaption><p>인증 필터의 주요 흐름</p></figcaption></figure><blockquote><p>인증 오류를 처리한다는 점에서 <code>ExceptionTranslationFilter</code>와 동작이 유사합니다. 다만, 내부적으로 발생할 수 있는 오류들을 Try-Catch로 잡아서 처리하기 때문에 인증 과정에서 실패하더라도 <code>ExceptionTranslationFilter</code>까지 도달하지 않고 설정된 <code>AuthenticationFailureHandler</code>를 사용합니다.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p></blockquote><h2 id=authorization>Authorization<a hidden class=anchor aria-hidden=true href=#authorization>#</a></h2><p>인증된 객체는 권한을 인가받게 되는데, 권한에 따라 자원(URL) 별로 접근제어가 가능합니다.</p><h3 id=authorities>Authorities<a hidden class=anchor aria-hidden=true href=#authorities>#</a></h3><p><a href=#authentication-object>위</a>에서 설명한 것처럼, 인증 객체는 생성과 동시에 권한(<code>authorities</code>)을 리스트로 갖게 됩니다.</p><ul><li>승인된 권한이라는 뜻에서 <code>GrantedAuthority</code>라는 클래스의 객체로 저장됩니다.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></li></ul><h3 id=authorizationmanager>AuthorizationManager<a hidden class=anchor aria-hidden=true href=#authorizationmanager>#</a></h3><p>인가를 관리하기 위한 인터페이스(API)입니다. <code>AuthorizationManager</code>는 승인된 권한을 바탕으로, 접근을 허용할지 아니면 거부할지를 결정합니다.</p><ul><li><p>내부적으로 다음과 같이 구현되어, 구현된 <code>check</code> 메서드를 default 메서드인 <code>verify</code>에서 위임하여 실행하는 식으로 동작합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>AuthorizationDecision</span><span class=w> </span><span class=nf>check</span><span class=p>(</span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Authentication</span><span class=o>&gt;</span><span class=w> </span><span class=n>authentication</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>secureObject</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>default</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>verify</span><span class=p>(</span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Authentication</span><span class=o>&gt;</span><span class=w> </span><span class=n>authentication</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>secureObject</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>AccessDeniedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>check</strong></p><ul><li>해당 요청을 승인할지, 거부할지를 결정합니다.</li><li>승인 : <code>new AuthorizationDecision(true)</code>를 반환합니다. 요청을 정상적으로 진행합니다.</li><li>거부 : <code>new AuthorizationDecision(false)</code>를 반환합니다. <code>AccessDeniedException</code> 예외가 발생합니다.</li></ul></li><li><p>이러한 API를 구현한 <strong>다양한 구현체</strong>가 있으며, 어플리케이션의 특성에 맞게 접근권한을 관리하는 것이 가능합니다.</p><blockquote><p>자세한 구현체들은 <a href=https://docs.spring.io/spring-security/reference/servlet/authorization/architecture.html#authz-delegate-authorization-manager>공식 문서</a>에서 확인할 수 있으니, 본인의 상황에 맞는 구현체를 선택하거나, 필요 시 커스터마이징 하여 사용하시면 됩니다.</p></blockquote></li></ul><figure><img loading=lazy src=authorization_hierarchy.png alt="인가 관리자 구현체(Spring Security Reference Doc)"><figcaption><p>인가 관리자 구현체(Spring Security Reference Doc)</p></figcaption></figure><h3 id=계층적-역할hierarchical-roles>계층적 역할(Hierarchical Roles)<a hidden class=anchor aria-hidden=true href=#계층적-역할hierarchical-roles>#</a></h3><p>대부분의 어플리케이션에서 역할<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>은 특정한 계층을 가지고 있습니다.</p><ul><li>예를 들어, 관리자 권한은 사용자가 가진 모든 권한을 사용 가능하고 거기에 추가로 관리자의 권한이 더해지는 식입니다.</li><li>그러나 이러한 계층적 권한은 어플리케이션을 복잡하게 만들 수 있습니다.<blockquote><p>전체 관리자와 중간 관리자, 사용자 세가지 권한이 있다고 하면 <code>사용자의 권한을 중간관리자는 모두 가져야</code> 하고, <code>전체 관리자는 중간 관리자와 사용자 관리자의 권한을 모두 가져야</code> 하는 복잡한 상황이 발생합니다.</p></blockquote></li><li>이를 쉽게 구현하기 위해, Spring Security는 계층적으로 권한을 관리할 수 있는 API를 제공합니다.<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>static</span><span class=w> </span><span class=n>RoleHierarchy</span><span class=w> </span><span class=nf>roleHierarchy</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>RoleHierarchyImpl</span><span class=p>.</span><span class=na>withDefaultRolePrefix</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>role</span><span class=p>(</span><span class=s>&#34;ADMIN&#34;</span><span class=p>).</span><span class=na>implies</span><span class=p>(</span><span class=s>&#34;STAFF&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>role</span><span class=p>(</span><span class=s>&#34;STAFF&#34;</span><span class=p>).</span><span class=na>implies</span><span class=p>(</span><span class=s>&#34;USER&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>role</span><span class=p>(</span><span class=s>&#34;USER&#34;</span><span class=p>).</span><span class=na>implies</span><span class=p>(</span><span class=s>&#34;GUEST&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>build</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>static</span><span class=w> </span><span class=n>MethodSecurityExpressionHandler</span><span class=w> </span><span class=nf>methodSecurityExpressionHandler</span><span class=p>(</span><span class=n>RoleHierarchy</span><span class=w> </span><span class=n>roleHierarchy</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>DefaultMethodSecurityExpressionHandler</span><span class=w> </span><span class=n>expressionHandler</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DefaultMethodSecurityExpressionHandler</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>expressionHandler</span><span class=p>.</span><span class=na>setRoleHierarchy</span><span class=p>(</span><span class=n>roleHierarchy</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>expressionHandler</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>위와 같이 설정하게 되면,<ul><li><code>ADMIN</code> 계정은 <code>STAFF, USER, GUEST</code> 권한 목록을 갖고,</li><li><code>STAFF</code> 계정은 <code>USER, GUEST</code> 권한 목록을 갖고,</li><li><code>USER</code> 계정은 <code>GUEST</code> 권한 목록을 갖게 됩니다.</li></ul></li></ul><blockquote><p>물론 위 설정에서처럼 <code>MethodSecurityExpressionHandler</code>를 통해 설정된 권한 계층을 <code>AuthorizationManager</code>에서 사용하지 않으면 적용되지 않습니다.</p></blockquote></li></ul><figure><img loading=lazy src=role_hierarchy.png alt="역할 계층 구조도[ADMIN > STAFF > USER > GUEST] : 하위 계층의 권한을 상위 계층이 기본적으로 포함하고 있습니다."><figcaption><p>역할 계층 구조도[ADMIN > STAFF > USER > GUEST] : 하위 계층의 권한을 상위 계층이 기본적으로 포함하고 있습니다.</p></figcaption></figure><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>Spring Security의 로직은 다음 API를 구현하여 활용할 수 있습니다.</p><ol><li>인증(Authentication) : <code>AuthenticationManager</code></li><li>인가(Authorization) : <code>AuthorizationManager</code></li></ol><blockquote><p>다음 포스팅에서는 Spring Security를 활용하여 TDD<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> 스타일로 인증 및 인가 로직을 개발해보겠습니다.</p></blockquote><h3 id=다음-포스팅>다음 포스팅<a hidden class=anchor aria-hidden=true href=#다음-포스팅>#</a></h3><ul><li><a href=https://leaf-nam.github.io/posts/spring_security/4>[Java]Spring Security(With TDD) 기본 인증 및 인가 구현하기</a></li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><table><thead><tr><th style=text-align:left>URL</th><th style=text-align:left>게시일자</th><th style=text-align:left>방문일자</th><th style=text-align:left>작성자</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://en.wikipedia.org/wiki/Professional_certification#Computer_technology>인증(Authorization)</a></td><td style=text-align:left>2024.11.22.</td><td style=text-align:left>2024.11.29.</td><td style=text-align:left>Wikipedia</td></tr><tr><td style=text-align:left><a href=https://en.wikipedia.org/wiki/Authentication>인가(Authentication)</a></td><td style=text-align:left>2024.11.6.</td><td style=text-align:left>2024.11.29.</td><td style=text-align:left>Wikipedia</td></tr><tr><td style=text-align:left><a href=http://web.archive.org/web/20190904190534/https://www.dirv.me/blog/2011/07/18/understanding-403-forbidden/index.html>Understanding 403 Forbidden</a></td><td style=text-align:left>2011.7.18.</td><td style=text-align:left>2024.11.29.</td><td style=text-align:left>Daniel Irvine</td></tr><tr><td style=text-align:left><a href=https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html>Spring Security Authentication</a></td><td style=text-align:left>-</td><td style=text-align:left>2024.11.29.</td><td style=text-align:left>Spring</td></tr><tr><td style=text-align:left><a href=https://docs.spring.io/spring-security/reference/servlet/authorization/architecture.html>Spring Security Authorization</a></td><td style=text-align:left>-</td><td style=text-align:left>2024.12.02.</td><td style=text-align:left>Spring</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>401은 인증 오류이지만, 영문명은 Unauthorized입니다. 이러한 <a href=http://web.archive.org/web/20190904190534/https://www.dirv.me/blog/2011/07/18/understanding-403-forbidden/index.html>개념을 이해하기 좋은 문서</a>가 있어 첨부합니다.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><code>SecurityContext</code>는 사용자 요청별로 관리되어야 하기 때문에 Thread-Safety하도록 <code>ThreadLocal 저장소</code>에 보관됩니다.</p><blockquote><p>Thread-Safety가 보장되지 않는다면 현재 사용자가 아닌 다른 사용자의 인증 객체에 접근할 가능성이 있어 보안 이슈가 발생할 수 있습니다.</p></blockquote>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:3><p>만약 사용자 요청을 캐싱하여 반환할 경우, 증명(Credentials)이 지워진 상태로 저장될 수 있습니다. 따라서 캐싱된 요청을 다시 인증하는게 불가능하기 때문에 별도의 인증 로직을 구성하거나 이러한 옵션을 해제해야 합니다.</p><p><figure><img loading=lazy src=credential_remove.png alt="자격증명 삭제 관련 문서"><figcaption><p>캐싱된 인증은 자격증명이 삭제된 상태로 저장될 수 있습니다.</p></figcaption></figure>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>실제로 디버깅을 통해 로그인 요청이 실패하여 재로그인 시도 시 <code>ExceptionTranslationFilter</code>의 <code>AuthenticationEntryPoint</code>로 이동하지 않고, <code>AbstractAuthenticationProcessingFilter</code>내부의 <code>AuthenticationFailureHandler</code>를 사용하여 로그인 페이지로 Redirect 하는 것을 확인할 수 있었습니다.
<img alt=디버깅1 loading=lazy src=/posts/spring_security/3/debug1.png>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><code>GrantedAuthority</code>객체는 기본적으로 <code>SimpleGrantedAuthority</code> 구현체를 사용할 수 있는데, 권한 요청 메서드인 <code>getAuthority()</code>를 실행했을 때 <code>ROLE_</code>형태의 Prefix를 가지는 권한(String)을 가져올 수 있습니다.</p><blockquote><p>이러한 권한 객체의 Prefix는 다음과 같이 변경해서 사용할 수 있습니다.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>  </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>static</span><span class=w> </span><span class=n>GrantedAuthorityDefaults</span><span class=w> </span><span class=nf>grantedAuthorityDefaults</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>GrantedAuthorityDefaults</span><span class=p>(</span><span class=s>&#34;MYPREFIX_&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:6><p>역할은 권한들의 집합입니다.</p><p>예를 들어, <strong>사용자 역할(ROLE_USER)</strong> 은 다음과 같이 <strong>로그인, 게시글 조회, 본인 게시글 수정, 본인 게시글 삭제</strong> 의 권한을 가질 수 있습니다.</p><blockquote><p><code>ROLE_USER = {LOGIN_AUTHORITY, GET_POST_AUTHORITY, PATCH_MY_POST_AUTHORITY, DELETE_MY_POST_AUTHORITY}</code></p></blockquote>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:7><p>Test Driven Development의 준말로, 단위 테스트를 먼저 작성한 후 구현하는 방식의 개발 방법론입니다.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://1eaf.site/tags/authentication/>Authentication</a></li><li><a href=https://1eaf.site/tags/authorization/>Authorization</a></li></ul><nav class=paginav><a class=prev href=https://1eaf.site/cote/bj_14942/><span class=title>« 이전 페이지</span><br><span>[Java]백준 14942 개미</span>
</a><a class=next href=https://1eaf.site/cote/programmers_136797/><span class=title>다음 페이지 »</span><br><span>[Java]Programmers 숫자 타자 대회</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on x" href="https://x.com/intent/tweet/?text=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29&amp;url=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f&amp;hashtags=authentication%2cauthorization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f&amp;title=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29&amp;summary=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29&amp;source=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f&title=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on whatsapp" href="https://api.whatsapp.com/send?text=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29%20-%20https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on telegram" href="https://telegram.me/share/url?text=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29&amp;url=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security 인증(Authentication)과 인가(Authorization) on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bJava%5dSpring%20Security%20%ec%9d%b8%ec%a6%9d%28Authentication%29%ea%b3%bc%20%ec%9d%b8%ea%b0%80%28Authorization%29&u=https%3a%2f%2f1eaf.site%2fposts%2fspring_security%2f3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://1eaf.site/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>