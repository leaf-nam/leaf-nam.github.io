<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Java]Spring Security WebMVC 기본 구조 | 봄을 기다리는 낙엽</title>
<meta name=keywords content="architecture"><meta name=description content="Spring Security의 기본 구조인 필터에 대해서 알아봅니다."><meta name=author content="Leaf"><link rel=canonical href=https://leaf-nam.github.io/posts/spring_security/1/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/posts/spring_security/1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/posts/spring_security/1/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="[Java]Spring Security WebMVC 기본 구조"><meta property="og:description" content="Spring Security의 기본 구조인 필터에 대해서 알아봅니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-06T19:19:20+09:00"><meta property="article:modified_time" content="2024-11-06T19:19:20+09:00"><meta property="article:tag" content="Architecture"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Java]Spring Security WebMVC 기본 구조"><meta name=twitter:description content="Spring Security의 기본 구조인 필터에 대해서 알아봅니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://leaf-nam.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Spring Security 파헤치기","item":"https://leaf-nam.github.io/posts/spring_security/"},{"@type":"ListItem","position":3,"name":"[Java]Spring Security WebMVC 기본 구조","item":"https://leaf-nam.github.io/posts/spring_security/1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Java]Spring Security WebMVC 기본 구조","name":"[Java]Spring Security WebMVC 기본 구조","description":"Spring Security의 기본 구조인 필터에 대해서 알아봅니다.","keywords":["architecture"],"articleBody":"도입 작성 배경 : 이번 토이프로젝트에서 Spring Security를 다루고 있는데, 기본 개념을 제대로 이해하지 못해서 많은 어려움을 겪었습니다. 이렇게 정리해두지 않으면 분명 나중에 또 까먹기 때문에, 공식 문서를 보면서 이해한 부분을 정리해두고 나중에 찾아보기 위해 기본 구조와 함께 예제들을 정리해볼 계획입니다. 사실 제가 내부구조를 정확히 아는 것도 아니고, 제 지식의 수준이 매우 얕기 때문에 Spring Security 공식문서에 적혀 있지 않은 내용은 잘못된 정보를 재생산 할 수 있다고 생각했습니다. 따라서 본 포스팅은 거의 Spring Security 6.3.4 레퍼런스 문서를 한글로 의역? 해석? 하는 수준에서 가볍게 봐주시면 좋을 것 같습니다.\nFilter : 공식문서에서도 Spring Security WebMVC의 구조와 관련된 페이지를 가보면, 대부분 필터에 대한 내용입니다. 결국 필터가 어떻게 동작하는지 이해하면 WebMVC에서 Spring Security의 기본 구조와 동작순서를 이해할 수 있기 때문에, 제목은 구조이지만 필터에 대한 설명 위주로 작성했습니다. Spring Reactive에서는 Servlet(WebMVC)에서와 전혀 다르게 동작한다고 하는데, 이 부분은 차후에 다루도록 하겠습니다.\n필터 Java servlet container의 필터 처리과정\n필터는 WebMVC 형태의 WAS를 다뤄보신 분들이라면 다들 사용해 보셨을 것 같습니다.\n사용자의 요청이 Controller(Spring에서는 DispatcherServlet)로 이동하기 전, 해당 요청을 검증하기 위한 단계를 나타냅니다.\n일종의 AOP1라고 할 수 있겠네요.\n필터는 스프링에서만 제공하는게 아닌, 자바 표준으로서 WAS(Servlet Container)에서 사용하기 위한 표준 스펙입니다.\n실제로 자바 표준 스펙에서 기본 제공하는 Filter 인터페이스의 형태는 다음과 같습니다.\npublic interface Filter { default void init(FilterConfig filterConfig) throws ServletException {} void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException; default void destroy() {} } doFilter 메소드의 인자를 보시면, 필터 인터페이스를 통해 가능한 역할은 크게 3가지입니다.\nServletRequest : 사용자 요청 검증(URL, Header 등) ServletResponse: 서버 응답 조작(status code, message body 등) FilterChain : 다음 필터로 요청 전송할지, 현재 필터에서 필터링할지 여부 결정 즉, 필터는 사용자 요청을 검증하고, 사전에 응답이 필요하면 세팅한 후 다음 필터로 요청을 전송하거나 필터링하는 일련의 과정이 반복됩니다. 이를 Filter Chaining이라고 표현합니다.\nSpring Security 필터 Spring에서는 자바 표준 필터를 Spring Container2에 호환하기 위해 다양한 기법을 사용합니다.\n아래 DelegatingFilterProxy와 FilterChainProxy는 AOP와 객체지향의 프록시 패턴3을 이해하지 않고 있다면, 조금 이해가 어려울 수 있습니다.\nDelegatingFilterProxy Bean으로 등록된 Filter를 품고 있는 DelegatingFilterProxy\nSpring이 Servlet Container(Java 표준)에서 사용하는 Filter를 Bean으로 등록 및 동작시키기 위한 프록시 객체입니다.\n여기서 Filters 내부의 Filter0, Filter2는 Spring이 관리하는 필터가 아닌 Servlet Container의 필터입니다.\n내부에 Spring Bean으로 등록된 Filter를 가지고 있으며, 해당 Bean에게 요청을 위임하여 동작시킵니다.\nServlet Container에서 사용하는 필터 인터페이스의 동작 사이에 Spring의 Bean을 끼워넣을 수 있는 일종의 JoinPoint4를 만들었다고 생각하시면 좋을 것 같습니다.\nFilterChainProxy Spring에서는 위의 DelegatingFilterProxy에 위임된 Bean Filter를 여러개 묶어서 Chain으로 연결한 것처럼 동작시킵니다. 해당 체인이 Spring Security에서 가장 핵심 로직인 SecurityFilterChain입니다.\nFilterChainProxy은 DelegatingFilterProxy로부터 위임된 필터 작업을 다음에 나올 SecurityFilterChain에게 요청을 위임하기 위한 프록시 객체입니다. SecurityFilterChain Proxy를 통해 SecurityFilterChain에게 요청이 위임됩니다.\n공식문서에서 위의 Proxy들을 언급한 이유는 결국 SecurityFilterChain의 구조를 설명하기 위함입니다.\n위의 그림에서처럼 두 개의 proxy 객체 덕분에 SecurityFilterChain에게 필터링을 위임할 수 있습니다.\n또한, 이러한 요청은 Matcher 로직을 통해 URI Path 기반으로 특정 패턴의 필터에게 요청을 위임하며, 패턴 별로 다른 로직의 필터를 동작시킬 수 있습니다.5\n앞의 필터에서 처리되지 않은 요청들은 모두 마지막 필터(/**)가 처리하겠죠?\n이러한 필터가 적용되는 순서 또한 중요합니다.\n예를 들어, 인가 관련 로직을 처리하기 전에 반드시 인증을 통해 해당 사용자에게 어떤 권한이 있는지를 확인해야 합니다.\n다음 소스코드를 참고하면 각각의 필터들이 내부적으로 어떤 순서로 동작하는지 확인할 수 있습니다. Custom Filter 등록하기 Filter를 구현하는 방법은 다음과 같습니다.\n필터를 상속받는 Bean을 구현합니다.\n이 때, Spring Security에서 제공하는 추상 클래스인 OncePerRequestFilter를 상속받아 사용할 것을 권장하고 있습니다. 해당 추상 클래스의 추상 메서드인 doFilterInternal를 구현하면, 템플릿 메서드 패턴6으로 하나의 요청에서 한번만 실행되는 필터를 생성할 수 있습니다. 당연히 하나의 요청에 한번만 실행되는거 아닌가..?하는 생각이 들어 찾아보니 servlet들끼리 dispatch를 하는 과정에서 여러번 실행될 수 있어 이런 필터를 통해 이번 요청에 이미 필터링을 거쳤는지 확인한다고 합니다.\nSecurityConfig에 등록합니다.\n@Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .addFilterBefore(new TenantFilter(), AuthorizationFilter.class); return http.build(); } 결론 스프링에서 사용하는 필터는 자바 표준스펙과 호환되며, 중간에 다양한 기능을 끼워넣기 위해 잘 설계되어 있어 Custom Filter를 쉽게 등록할 수 있다!\n예외처리, 캐싱 관련된 내용도 한번에 작성하려고 했는데, 분량이 너무 길어져서 다음 포스트로 넘기겠습니다.\n다음 포스팅 [Java]Spring Security 예외처리, 캐싱, 로깅 [Java]Spring Security 인증(Authentication)과 인가(Authorization) References Link 게시일자 방문일자 작성자 Spring Security Docs - 2024.11.05. Spring Java Servlet Filter Docs - 2024.11.05. Oracle Spring Security Filter Order Source Code - 2024.11.05. Spring Once Per Request Filter When to Use 2018.03.18. 2024.11.05. StackOverflow Aspect Orient Programming - 관점 지향 프로그래밍 : 특정 로직의 핵심 관점(종단 관심사)과 부가 관점(횡단 관심사)을 나눈 뒤 각각을 모듈화하는 기법을 말합니다. 필터는 핵심 비즈니스 로직 전단계의 전처리 과정을 모듈화하는 Aspect(횡단 관심사)의 일종입니다. ↩︎\nApplication Context, Bean Factory, Bean Container 혹은 IOC Container라고도 합니다. ↩︎\nProxy Pattern - 프록시 패턴 : 본인 내부에 다른 객체의 참조를 갖고 있다가, 특정 작업의 요청을 내부 객체에 위임하는 형태의 디자인 패턴입니다. 이를 통해 접근 제어를 하거나 특정 부가기능을 수행할 수 있습니다. ↩︎\nAspectJ에서 사용하는 개념으로, 횡단 관심사를 처리할 로직을 끼워넣을 지점을 결정합니다. ↩︎\nSpring에서는 이러한 SecurityFilterChain을 DelegatingFilterChain이 아닌 FilterChainProxy로 등록하는데, 이는 DelegatingFilterChain을 그대로 사용하면 기존 필터와 동일한 구조로 동작해야 하기 때문이라고 합니다. FilterChainProxy로 등록함으로써 스프링의 다양한 성능 최적화나 메모리 누수 방지 등등의 다양한 동작을 적용할 수 있고, 무엇보다 URL을 보고 필터 동작여부를 결정하는 것이 아니라, RequestMatcher를 활용할 수 있는 것도 FilterChainProxy로서 등록되기 때문이라고 하네요! 기존 로직에 부가기능을 추가한 뒤 다른 객체에게 위임하여 동작시킨다는 측면에서 일종의 데코레이터 패턴이라고 볼 수 있겠네요.\n↩︎ Template Method Pattern - 템플릿 메소드 패턴 : 상위 객체의 알고리즘을 하위 객체에서 구현하도록 설계하여 전체 구조를 변경하지 않고 특정 단계의 로직만 변경할 수 있게 합니다. ↩︎\n","wordCount":"846","inLanguage":"ko","datePublished":"2024-11-06T19:19:20+09:00","dateModified":"2024-11-06T19:19:20+09:00","author":{"@type":"Person","name":"Leaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leaf-nam.github.io/posts/spring_security/1/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"https://leaf-nam.github.io/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/posts/spring_security/>Spring Security 파헤치기</a></div><h1 class="post-title entry-hint-parent">[Java]Spring Security WebMVC 기본 구조</h1><div class=post-description>Spring Security의 기본 구조인 필터에 대해서 알아봅니다.</div><div class=post-meta><span title='2024-11-06 19:19:20 +0900 KST'>2024. 11. 6.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;846 단어&nbsp;·&nbsp;Leaf&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content/ rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#도입>도입</a></li><li><a href=#필터>필터</a></li><li><a href=#spring-security-필터>Spring Security 필터</a><ul><li><a href=#delegatingfilterproxy>DelegatingFilterProxy</a></li><li><a href=#filterchainproxy>FilterChainProxy</a></li><li><a href=#securityfilterchain>SecurityFilterChain</a></li><li><a href=#custom-filter-등록하기>Custom Filter 등록하기</a></li></ul></li><li><a href=#결론>결론</a><ul><li><a href=#다음-포스팅>다음 포스팅</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=도입>도입<a hidden class=anchor aria-hidden=true href=#도입>#</a></h2><ul><li><strong>작성 배경</strong> :
이번 토이프로젝트에서 Spring Security를 다루고 있는데, 기본 개념을 제대로 이해하지 못해서 많은 어려움을 겪었습니다. 이렇게 정리해두지 않으면 분명 나중에 또 까먹기 때문에, 공식 문서를 보면서 이해한 부분을 정리해두고 나중에 찾아보기 위해 기본 구조와 함께 예제들을 정리해볼 계획입니다.<blockquote><p>사실 제가 내부구조를 정확히 아는 것도 아니고, 제 지식의 수준이 매우 얕기 때문에 Spring Security 공식문서에 적혀 있지 않은 내용은 잘못된 정보를 재생산 할 수 있다고 생각했습니다. 따라서 본 포스팅은 거의 <a href=https://docs.spring.io/spring-security/reference/index.html>Spring Security 6.3.4</a> 레퍼런스 문서를 한글로 의역? 해석? 하는 수준에서 가볍게 봐주시면 좋을 것 같습니다.</p></blockquote></li><li><strong>Filter</strong> :
공식문서에서도 <a href=https://docs.spring.io/spring-security/reference/servlet/architecture.html>Spring Security WebMVC의 구조와 관련된 페이지</a>를 가보면, 대부분 필터에 대한 내용입니다. 결국 필터가 어떻게 동작하는지 이해하면 WebMVC에서 Spring Security의 기본 구조와 동작순서를 이해할 수 있기 때문에, 제목은 구조이지만 필터에 대한 설명 위주로 작성했습니다.<blockquote><p>Spring Reactive에서는 Servlet(WebMVC)에서와 전혀 다르게 동작한다고 하는데, 이 부분은 차후에 다루도록 하겠습니다.</p></blockquote></li></ul><h2 id=필터>필터<a hidden class=anchor aria-hidden=true href=#필터>#</a></h2><figure><img loading=lazy src=servlet_filter.png alt="Java servlet container의 필터 처리과정"><figcaption><p>Java servlet container의 필터 처리과정</p></figcaption></figure><ul><li><p>필터는 WebMVC 형태의 WAS를 다뤄보신 분들이라면 다들 사용해 보셨을 것 같습니다.</p></li><li><p>사용자의 요청이 Controller(Spring에서는 DispatcherServlet)로 이동하기 전, 해당 요청을 검증하기 위한 단계를 나타냅니다.</p></li><li><p>일종의 AOP<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>라고 할 수 있겠네요.</p></li><li><p>필터는 스프링에서만 제공하는게 아닌, 자바 표준으로서 WAS(Servlet Container)에서 사용하기 위한 표준 스펙입니다.</p></li><li><p>실제로 <a href=https://docs.oracle.com/javaee/5/api/javax/servlet/Filter.html>자바 표준 스펙</a>에서 기본 제공하는 Filter 인터페이스의 형태는 다음과 같습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Filter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>default</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>init</span><span class=p>(</span><span class=n>FilterConfig</span><span class=w> </span><span class=n>filterConfig</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>ServletException</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>doFilter</span><span class=p>(</span><span class=n>ServletRequest</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>ServletResponse</span><span class=w> </span><span class=n>response</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>FilterChain</span><span class=w> </span><span class=n>filterChain</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=p>,</span><span class=w> </span><span class=n>ServletException</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>default</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>destroy</span><span class=p>()</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>doFilter 메소드의 인자를 보시면, 필터 인터페이스를 통해 가능한 역할은 크게 3가지입니다.</p><ul><li>ServletRequest : 사용자 요청 검증(URL, Header 등)</li><li>ServletResponse: 서버 응답 조작(status code, message body 등)</li><li>FilterChain : 다음 필터로 요청 전송할지, 현재 필터에서 필터링할지 여부 결정</li></ul></li><li><p>즉, 필터는 사용자 요청을 검증하고, 사전에 응답이 필요하면 세팅한 후 다음 필터로 요청을 전송하거나 필터링하는 일련의 과정이 반복됩니다. 이를 <strong>Filter Chaining</strong>이라고 표현합니다.</p></li></ul><h2 id=spring-security-필터>Spring Security 필터<a hidden class=anchor aria-hidden=true href=#spring-security-필터>#</a></h2><p>Spring에서는 자바 표준 필터를 Spring Container<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>에 호환하기 위해 다양한 기법을 사용합니다.</p><blockquote><p>아래 DelegatingFilterProxy와 FilterChainProxy는 AOP와 객체지향의 프록시 패턴<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>을 이해하지 않고 있다면, 조금 이해가 어려울 수 있습니다.</p></blockquote><h3 id=delegatingfilterproxy>DelegatingFilterProxy<a hidden class=anchor aria-hidden=true href=#delegatingfilterproxy>#</a></h3><figure><img loading=lazy src=delegatingFilterProxy.png alt="Bean으로 등록된 Filter를 품고 있는 DelegatingFilterProxy"><figcaption><p>Bean으로 등록된 Filter를 품고 있는 DelegatingFilterProxy</p></figcaption></figure><ul><li><p>Spring이 Servlet Container(Java 표준)에서 사용하는 Filter를 Bean으로 등록 및 동작시키기 위한 프록시 객체입니다.</p><blockquote><p>여기서 Filters 내부의 Filter0, Filter2는 Spring이 관리하는 필터가 아닌 Servlet Container의 필터입니다.</p></blockquote></li><li><p>내부에 Spring Bean으로 등록된 Filter를 가지고 있으며, 해당 Bean에게 요청을 위임하여 동작시킵니다.</p></li><li><p>Servlet Container에서 사용하는 필터 인터페이스의 동작 사이에 Spring의 Bean을 끼워넣을 수 있는 일종의 JoinPoint<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>를 만들었다고 생각하시면 좋을 것 같습니다.</p></li></ul><h3 id=filterchainproxy>FilterChainProxy<a hidden class=anchor aria-hidden=true href=#filterchainproxy>#</a></h3><ul><li>Spring에서는 위의 DelegatingFilterProxy에 위임된 Bean Filter를 여러개 묶어서 Chain으로 연결한 것처럼 동작시킵니다.<blockquote><p>해당 체인이 Spring Security에서 가장 핵심 로직인 SecurityFilterChain입니다.</p></blockquote></li><li>FilterChainProxy은 DelegatingFilterProxy로부터 위임된 필터 작업을 다음에 나올 SecurityFilterChain에게 요청을 위임하기 위한 프록시 객체입니다.</li></ul><h3 id=securityfilterchain>SecurityFilterChain<a hidden class=anchor aria-hidden=true href=#securityfilterchain>#</a></h3><figure><img loading=lazy src=securityFilterChain.png alt="Proxy를 통해 SecurityFilterChain에게 요청이 위임됩니다."><figcaption><p>Proxy를 통해 SecurityFilterChain에게 요청이 위임됩니다.</p></figcaption></figure><ul><li><p>공식문서에서 위의 Proxy들을 언급한 이유는 결국 SecurityFilterChain의 구조를 설명하기 위함입니다.</p><blockquote><p>위의 그림에서처럼 두 개의 proxy 객체 덕분에 SecurityFilterChain에게 필터링을 위임할 수 있습니다.</p></blockquote></li><li><p>또한, 이러한 요청은 Matcher 로직을 통해 URI Path 기반으로 특정 패턴의 필터에게 요청을 위임하며, 패턴 별로 다른 로직의 필터를 동작시킬 수 있습니다.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><blockquote><p>앞의 필터에서 처리되지 않은 요청들은 모두 마지막 필터(/**)가 처리하겠죠?</p></blockquote></li><li><p>이러한 필터가 적용되는 순서 또한 중요합니다.</p><blockquote><p>예를 들어, 인가 관련 로직을 처리하기 전에 반드시 인증을 통해 해당 사용자에게 어떤 권한이 있는지를 확인해야 합니다.</p></blockquote><ul><li><a href=https://github.com/spring-projects/spring-security/blob/6.3.4/config/src/main/java/org/springframework/security/config/annotation/web/builders/FilterOrderRegistration.java>다음 소스코드</a>를 참고하면 각각의 필터들이 내부적으로 어떤 순서로 동작하는지 확인할 수 있습니다.</li></ul></li></ul><h3 id=custom-filter-등록하기>Custom Filter 등록하기<a hidden class=anchor aria-hidden=true href=#custom-filter-등록하기>#</a></h3><ul><li><p>Filter를 구현하는 방법은 다음과 같습니다.</p><ol><li><p><strong>필터를 상속받는 Bean을 구현합니다.</strong></p><ul><li>이 때, Spring Security에서 제공하는 추상 클래스인 OncePerRequestFilter를 상속받아 사용할 것을 권장하고 있습니다.</li><li>해당 추상 클래스의 추상 메서드인 doFilterInternal를 구현하면, 템플릿 메서드 패턴<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>으로 하나의 요청에서 한번만 실행되는 필터를 생성할 수 있습니다.<blockquote><p>당연히 하나의 요청에 한번만 실행되는거 아닌가..?하는 생각이 들어 찾아보니 <a href=https://stackoverflow.com/questions/50410901/genericfilterbean-vs-onceperrequestfilter-when-to-use-each>servlet들끼리 dispatch를 하는 과정에서 여러번 실행될 수 있어</a> 이런 필터를 통해 이번 요청에 이미 필터링을 거쳤는지 확인한다고 합니다.</p></blockquote></li></ul></li><li><p><strong>SecurityConfig에 등록합니다.</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>SecurityFilterChain</span><span class=w> </span><span class=nf>filterChain</span><span class=p>(</span><span class=n>HttpSecurity</span><span class=w> </span><span class=n>http</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>addFilterBefore</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>TenantFilter</span><span class=p>(),</span><span class=w> </span><span class=n>AuthorizationFilter</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>http</span><span class=p>.</span><span class=na>build</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ol></li></ul><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p><strong>스프링에서 사용하는 필터는 자바 표준스펙과 호환되며, 중간에 다양한 기능을 끼워넣기 위해 잘 설계되어 있어 Custom Filter를 쉽게 등록할 수 있다!</strong></p><blockquote><p>예외처리, 캐싱 관련된 내용도 한번에 작성하려고 했는데, 분량이 너무 길어져서 다음 포스트로 넘기겠습니다.</p></blockquote><h3 id=다음-포스팅>다음 포스팅<a hidden class=anchor aria-hidden=true href=#다음-포스팅>#</a></h3><ul><li><a href=https://leaf-nam.github.io/posts/spring_security/2>[Java]Spring Security 예외처리, 캐싱, 로깅</a></li><li><a href=https://leaf-nam.github.io/posts/spring_security/3>[Java]Spring Security 인증(Authentication)과 인가(Authorization)</a></li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><table><thead><tr><th style=text-align:left>Link</th><th style=text-align:left>게시일자</th><th style=text-align:left>방문일자</th><th style=text-align:left>작성자</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://docs.spring.io/spring-security/reference/index.html>Spring Security Docs</a></td><td style=text-align:left>-</td><td style=text-align:left>2024.11.05.</td><td style=text-align:left>Spring</td></tr><tr><td style=text-align:left><a href=https://docs.oracle.com/javaee/5/api/javax/servlet/Filter.html>Java Servlet Filter Docs</a></td><td style=text-align:left>-</td><td style=text-align:left>2024.11.05.</td><td style=text-align:left>Oracle</td></tr><tr><td style=text-align:left><a href=https://github.com/spring-projects/spring-security/blob/6.3.4/config/src/main/java/org/springframework/security/config/annotation/web/builders/FilterOrderRegistration.java>Spring Security Filter Order Source Code</a></td><td style=text-align:left>-</td><td style=text-align:left>2024.11.05.</td><td style=text-align:left>Spring</td></tr><tr><td style=text-align:left><a href=https://stackoverflow.com/questions/50410901/genericfilterbean-vs-onceperrequestfilter-when-to-use-each>Once Per Request Filter When to Use</a></td><td style=text-align:left>2018.03.18.</td><td style=text-align:left>2024.11.05.</td><td style=text-align:left>StackOverflow</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://ko.wikipedia.org/wiki/%EA%B4%80%EC%A0%90_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D>Aspect Orient Programming</a> - 관점 지향 프로그래밍 : 특정 로직의 핵심 관점(종단 관심사)과 부가 관점(횡단 관심사)을 나눈 뒤 각각을 모듈화하는 기법을 말합니다.
필터는 핵심 비즈니스 로직 전단계의 전처리 과정을 모듈화하는 Aspect(횡단 관심사)의 일종입니다.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Application Context, Bean Factory, Bean Container 혹은 IOC Container라고도 합니다.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4>Proxy Pattern</a> - 프록시 패턴 : 본인 내부에 다른 객체의 참조를 갖고 있다가, 특정 작업의 요청을 내부 객체에 위임하는 형태의 디자인 패턴입니다. 이를 통해 접근 제어를 하거나 특정 부가기능을 수행할 수 있습니다.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://ko.wikipedia.org/wiki/AspectJ>AspectJ</a>에서 사용하는 개념으로, 횡단 관심사를 처리할 로직을 끼워넣을 지점을 결정합니다.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><ul><li>Spring에서는 이러한 SecurityFilterChain을 DelegatingFilterChain이 아닌 FilterChainProxy로 등록하는데, 이는 DelegatingFilterChain을 그대로 사용하면 기존 필터와 동일한 구조로 동작해야 하기 때문이라고 합니다.</li><li>FilterChainProxy로 등록함으로써 스프링의 다양한 성능 최적화나 메모리 누수 방지 등등의 다양한 동작을 적용할 수 있고, 무엇보다 URL을 보고 필터 동작여부를 결정하는 것이 아니라, RequestMatcher를 활용할 수 있는 것도 FilterChainProxy로서 등록되기 때문이라고 하네요!<blockquote><p>기존 로직에 부가기능을 추가한 뒤 다른 객체에게 위임하여 동작시킨다는 측면에서 일종의 데코레이터 패턴이라고 볼 수 있겠네요.</p></blockquote></li></ul>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:6><p><a href=https://ko.wikipedia.org/wiki/%ED%85%9C%ED%94%8C%EB%A6%BF_%EB%A9%94%EC%86%8C%EB%93%9C_%ED%8C%A8%ED%84%B4>Template Method Pattern</a> - 템플릿 메소드 패턴 : 상위 객체의 알고리즘을 하위 객체에서 구현하도록 설계하여 전체 구조를 변경하지 않고 특정 단계의 로직만 변경할 수 있게 합니다.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://leaf-nam.github.io/tags/architecture/>Architecture</a></li></ul><nav class=paginav><a class=prev href=https://leaf-nam.github.io/cote/programmers_131701/><span class=title>« 이전 페이지</span><br><span>[Java]Programmers 연속 부분 수열 합의 개수</span>
</a><a class=next href=https://leaf-nam.github.io/cote/hackerrank_lego_blocks/><span class=title>다음 페이지 »</span><br><span>[Java]HackerRank Lego Blocks</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on x" href="https://x.com/intent/tweet/?text=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f&amp;hashtags=architecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f&amp;title=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0&amp;summary=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0&amp;source=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f&title=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on whatsapp" href="https://api.whatsapp.com/send?text=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0%20-%20https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on telegram" href="https://telegram.me/share/url?text=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Spring Security WebMVC 기본 구조 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bJava%5dSpring%20Security%20WebMVC%20%ea%b8%b0%eb%b3%b8%20%ea%b5%ac%ec%a1%b0&u=https%3a%2f%2fleaf-nam.github.io%2fposts%2fspring_security%2f1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>