<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DB 이중화 및 CQRS 패턴의 중요성 | 봄을 기다리는 낙엽</title>
<meta name=keywords content="replication,architecture,CQRS"><meta name=description content="CQRS패턴을 구현하기 위한 DB이중화 기법에 대해 알아봅니다."><meta name=author content="Leaf"><link rel=canonical href=https://leaf-nam.github.io/posts/cqrs/1/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/posts/cqrs/1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/posts/cqrs/1/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="DB 이중화 및 CQRS 패턴의 중요성"><meta property="og:description" content="CQRS패턴을 구현하기 위한 DB이중화 기법에 대해 알아봅니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-11T22:51:52+09:00"><meta property="article:modified_time" content="2024-03-11T22:51:52+09:00"><meta property="article:tag" content="Replication"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="CQRS"><meta property="og:image" content="https://leaf-nam.github.io/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://leaf-nam.github.io/cover.jpg"><meta name=twitter:title content="DB 이중화 및 CQRS 패턴의 중요성"><meta name=twitter:description content="CQRS패턴을 구현하기 위한 DB이중화 기법에 대해 알아봅니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://leaf-nam.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[MySQL, Java]Spring CQRS 패턴 구현을 위한 DB 이중화","item":"https://leaf-nam.github.io/posts/cqrs/"},{"@type":"ListItem","position":3,"name":"DB 이중화 및 CQRS 패턴의 중요성","item":"https://leaf-nam.github.io/posts/cqrs/1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DB 이중화 및 CQRS 패턴의 중요성","name":"DB 이중화 및 CQRS 패턴의 중요성","description":"CQRS패턴을 구현하기 위한 DB이중화 기법에 대해 알아봅니다.","keywords":["replication","architecture","CQRS"],"articleBody":"도입 우리가 일상에서 매일 접속하는 인터넷은 전세계의 수많은 사용자가 사용하는 만큼 항상 엄청난 트래픽이 발생합니다. 이러한 트래픽의 가장 중심에는 데이터베이스가 있습니다. 결국 사용자는 데이터베이스를 통해 다양한 정보를 획득합니다.\n이러한 데이터베이스의 성능을 늘리기 위해 개발자들은 다양한 시도를 합니다. 그중에서도 이번에는 데이터베이스 이중화와 CQRS 패턴에 대해 알아보고, 이를 실제로 가상서버 및 코드로 구현해보려 합니다.\nDB 이중화 기법 데이터베이스 이중화에는 다양한 장점이 있습니다. 대표적으로\n장애 대응(Failover) : DB가 1개라면, 해당 DB가 다양한 원인1에 의해 장애가 발생했을 시 서비스 운영이 불가능합니다. DB를 이중화한다면 이러한 장애에 신속히 대응할 수 있으며, 차후 손실된 데이터를 복구하는 것도 가능합니다. 부하 분산(Load Balancing) : 하나의 DB가 받던 부하를 여러 DB로 분산한다면, 병목현상으로 인한 장애를 예방할 수 있을 뿐 아니라, 요청에 대한 신속한 응답을 기대할 수 있습니다. 또한, DB 이중화 기법을 통해 시스템의 두가지 성질을 달성할 수 있습니다.\nHA(High Availability; 고가용성) 시스템을 최대한 중단 시간 없이 운영할 수 있는 특성을 말합니다. HA를 판단하는 기준은 Availability가 있으며, 가용성에 따른 서비스 제공시간2을 계산할 수 있습니다. Availability Downtime per year 90% 36.5일 99.99% 52.6분 99.999% 5분 26초 … … 99.9999999% 31.56 밀리초 DR(Disaster Recovery; 재해복구) 자연재해 혹은 인위적 사고로부터 핵심 시스템을 복구하는 절차 혹은 지속성을 말합니다. 이러한 DR의 목표와 실제는 RPO, RTO, RTA로 나뉘게 됩니다. RTO(Recovery Time Objective) : 비즈니스의 지속성을 위한 복구 목표시간입니다. RTA(Recovery Time Actual) : 실제 복구하는데 걸리는 시간입니다. RPO(Recovery Point Objective) : 사고가 발생하면서 실제로 손실이 발생하는 시간입니다. RTO, RPO에 대한 설명\n그럼 이러한 이중화 기법에는 어떠한 것이 있는지 알아보겠습니다.\n사실 인프라나 하드웨어적 측면에서 훨씬 다양한 기법들이 있고, 오늘은 단일 소프트웨어(취준생) 수준의 이중화 기법을 알아보겠습니다.\nReplication 쌍둥이를 만듭니다.\n동일한 데이터를 가지는 복제 데이터베이스를 생성합니다. 마스터(master)와 슬레이브(slave)로 구성되어 슬레이브가 마스터의 데이터를 복제하는 방식으로 동작합니다. Clustering 동일한 작업을 하는 서버를 클러스터로 분리해 가용성을 확보할 수 있습니다.\n동일한 작업을 여러 노드를 통해 수행하는 서비스 방식을 말하며, 동일한 업무를 처리해야 하기에 동일한 정보를 가지고 있어야 합니다. 작업을 분산하거나 동기화하는 과정에서 오버헤드가 발생할 수 있으며, 이러한 작업 스케줄링 및 동기화가 클러스터링에서 해결해야 할 과제입니다. Shading 샤딩은 pk를 분배하는 전략이 중요합니다.\n하나의 작업을 여러 노드에 분산해서 작업하는 서비스 방식을 말합니다. 데이터베이스에서는 데이터를 분산해서 저장하는 방식을 말하며, 이렇게 분산 저장된 데이터를 적절하게 인덱싱하는 것이 중요합니다. Clustering과 헷갈릴 수 있지만, Clustering은 동일한 DB를 여러개 만드는 반면, Shading은 하나의 DB를 쪼개는 방식입니다. Shading은 수평 분할로, 한 테이블의 행을 여러개의 DB로 분리한다고 생각하며 될 것 같습니다.\nCQRS 패턴 지금까지 DB 이중화의 목적과 종류에 대해 알아보았는데요, 그럼 CQRS패턴은 무엇일까요?\n정의 CQRS3패턴은 Command(Create, Update, Delete)와 Query(Read)의 책임을 분리하라는 원칙을 구현한 패턴입니다.\n목적 Command와 Query를 분리하는 이유는 다음과 같습니다.\n읽기와 쓰기의 빈도 차이 : 어플리케이션 로직을 생각해보면, 통상 쓰기보다 읽기가 훨씬 많이 발생합니다. Command와 Query를 분리한다면, Query를 수행하는 DB를 Command용 DB보다 많이 생성함으로써 이러한 비율을 맞춰 서비스를 최적화할 수 있습니다. 확장성 : 위에서 설명한 비율을 고민하며 독립적으로 DB를 확장할 수 있습니다. 트랜잭션 : Command는 데이터를 변경하기에 트랜잭션이 발생하며, Query는 통상 읽기 전용으로 이루어집니다. 트랜잭션을 처리하는 로직이 분리되면 데이터 변경을 위한 로직을 관리하기 쉬워집니다. 보안 : 쓰기 권한을 가진 요청을 통해서만 데이터가 변경되는지 확인하기가 용이해집니다. 구현 이러한 CQRS패턴은 어플리케이션 계층에서도 구현할 수 있지만, 데이터베이스를 분리하여 두 작업을 원천 분리할 수 있습니다.\n그 중 대표적인 방법이 위에서 설명했던 Replication을 응용한 방식입니다. Replication은 위에서 설명한 것처럼 Master DB에서 변경된 데이터를 Slave DB에서 그대로 복제하는 특징을 가지고 있습니다.\n따라서 Command는 Master DB에서 수행하고, Query는 Slave DB에서 수행하는 방식으로 Command와 Query를 분리할 수 있습니다.\n결론 다양한 이점을 가진 DB 이중화의 다양한 방식을 알아보았고, 이를 통해 CQRS 패턴을 구현할 수 있습니다. 다음 시간부터는 MySQL에서 제공하는 Replication기술을 활용해 SpringBoot Server에서 CQRS패턴을 활용하는 예제를 직접 구현해보겠습니다.\n이제야 좀 기술블로그 같은 주제를 다루는 것 같네요. 앞으로도 프로젝트나 다양한 이슈로부터 얻는 노하우와 기술들을 정리해 나가겠습니다.\nReferences URL 게시일자 방문일자 작성자 https://travislife.tistory.com/29 2020.08.03. 2024.03.12. 트레비스의 IT라이프 https://if.kakao.com/ 2022.12.09. 2024.03.12. if-kakao-2022 https://en.wikipedia.org/wiki/Disaster_recovery 2024.03.05. 2024.03.12. wikipedia https://techblog.woowahan.com/2687/ 2020.07.06. 2024.03.12. 송재욱, 전병두 https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cqrs 미등록 2024.03.12. Azure Storage 개발자 혹은 DB관리자의 실수, 정전, 천재지변, 해커의 공격 등 정말 다양한 원인이 있으며 이러한 모든 원인을 회피하는 것은 불가능합니다. 실제로 2022년 10월 15일 발생한 카카오 데이터센터 화재로 1개월 이상 복구작업을 하기도 했습니다. ↩︎\n고가용성 시스템을 추구하는 Erlang 은 nine nines(99.9999999%)를 달성했다고 하네요. ↩︎\nCommand and Query Responsibility Segregation; 명령과 쿼리 분리의 원칙입니다. ↩︎\n","wordCount":"651","inLanguage":"ko","image":"https://leaf-nam.github.io/cover.jpg","datePublished":"2024-03-11T22:51:52+09:00","dateModified":"2024-03-11T22:51:52+09:00","author":{"@type":"Person","name":"Leaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leaf-nam.github.io/posts/cqrs/1/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"https://leaf-nam.github.io/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/posts/cqrs/>[MySQL, Java]Spring CQRS 패턴 구현을 위한 DB 이중화</a></div><h1 class="post-title entry-hint-parent">DB 이중화 및 CQRS 패턴의 중요성</h1><div class=post-description>CQRS패턴을 구현하기 위한 DB이중화 기법에 대해 알아봅니다.</div><div class=post-meta><span title='2024-03-11 22:51:52 +0900 KST'>2024. 3. 11.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;651 단어&nbsp;·&nbsp;Leaf&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content/ rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager srcset="https://leaf-nam.github.io/posts/cqrs/1/cover_hu17231706732791268535.jpg 360w ,https://leaf-nam.github.io/posts/cqrs/1/cover_hu18087869244214901015.jpg 480w ,https://leaf-nam.github.io/posts/cqrs/1/cover_hu15337030456852236604.jpg 720w ,https://leaf-nam.github.io/posts/cqrs/1/cover_hu11672426780037108565.jpg 1080w ,https://leaf-nam.github.io/posts/cqrs/1/cover_hu9200532881031635483.jpg 1500w ,https://leaf-nam.github.io/posts/cqrs/1/cover.jpg 5437w" sizes="(min-width: 768px) 720px, 100vw" src=https://leaf-nam.github.io/posts/cqrs/1/cover.jpg alt=replication width=5437 height=3625><p>DB를 이중화하는 것은 선택이 아닙니다.</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#도입>도입</a></li><li><a href=#db-이중화-기법>DB 이중화 기법</a><ul><li><a href=#replication>Replication</a></li><li><a href=#clustering>Clustering</a></li><li><a href=#shading>Shading</a></li></ul></li><li><a href=#cqrs-패턴>CQRS 패턴</a><ul><li><a href=#정의>정의</a></li><li><a href=#목적>목적</a></li><li><a href=#구현>구현</a></li></ul></li><li><a href=#결론>결론</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=도입>도입<a hidden class=anchor aria-hidden=true href=#도입>#</a></h2><p>우리가 일상에서 매일 접속하는 인터넷은 전세계의 수많은 사용자가 사용하는 만큼 항상 엄청난 트래픽이 발생합니다. 이러한 트래픽의 가장 중심에는 데이터베이스가 있습니다. 결국 사용자는 데이터베이스를 통해 다양한 정보를 획득합니다.</p><p>이러한 데이터베이스의 성능을 늘리기 위해 개발자들은 다양한 시도를 합니다. 그중에서도 이번에는 데이터베이스 이중화와 CQRS 패턴에 대해 알아보고, 이를 실제로 가상서버 및 코드로 구현해보려 합니다.</p><h2 id=db-이중화-기법>DB 이중화 기법<a hidden class=anchor aria-hidden=true href=#db-이중화-기법>#</a></h2><p>데이터베이스 이중화에는 다양한 장점이 있습니다. 대표적으로</p><ol><li><strong>장애 대응(Failover)</strong> : DB가 1개라면, 해당 DB가 다양한 원인<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>에 의해 장애가 발생했을 시 서비스 운영이 불가능합니다. DB를 이중화한다면 이러한 장애에 신속히 대응할 수 있으며, 차후 손실된 데이터를 복구하는 것도 가능합니다.</li><li><strong>부하 분산(Load Balancing)</strong> : 하나의 DB가 받던 부하를 여러 DB로 분산한다면, 병목현상으로 인한 장애를 예방할 수 있을 뿐 아니라, 요청에 대한 신속한 응답을 기대할 수 있습니다.</li></ol><p>또한, DB 이중화 기법을 통해 시스템의 두가지 성질을 달성할 수 있습니다.</p><ul><li><strong>HA(High Availability; 고가용성)</strong><ul><li>시스템을 최대한 중단 시간 없이 운영할 수 있는 특성을 말합니다.</li><li>HA를 판단하는 기준은 Availability가 있으며, 가용성에 따른 서비스 제공시간<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>을 계산할 수 있습니다.<table><thead><tr><th>Availability</th><th>Downtime per year</th></tr></thead><tbody><tr><td>90%</td><td>36.5일</td></tr><tr><td>99.99%</td><td>52.6분</td></tr><tr><td>99.999%</td><td>5분 26초</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr><tr><td>99.9999999%</td><td>31.56 밀리초</td></tr></tbody></table></li></ul></li><li><strong>DR(Disaster Recovery; 재해복구)</strong><ul><li>자연재해 혹은 인위적 사고로부터 핵심 시스템을 복구하는 절차 혹은 지속성을 말합니다.</li><li>이러한 DR의 목표와 실제는 RPO, RTO, RTA로 나뉘게 됩니다.</li><li>RTO(Recovery Time Objective) : 비즈니스의 지속성을 위한 복구 목표시간입니다.</li><li>RTA(Recovery Time Actual) : 실제 복구하는데 걸리는 시간입니다.</li><li>RPO(Recovery Point Objective) : 사고가 발생하면서 실제로 손실이 발생하는 시간입니다.<figure><a href=https://en.wikipedia.org/wiki/Disaster_recovery><img loading=lazy src=dr_rpo_rto.png alt="RTO, RPO에 대한 설명"></a><figcaption><p>RTO, RPO에 대한 설명</p></figcaption></figure></li></ul></li></ul><p>그럼 이러한 이중화 기법에는 어떠한 것이 있는지 알아보겠습니다.</p><blockquote><p>사실 인프라나 하드웨어적 측면에서 훨씬 다양한 기법들이 있고, 오늘은 단일 소프트웨어(<del>취준생</del>) 수준의 이중화 기법을 알아보겠습니다.</p></blockquote><h3 id=replication>Replication<a hidden class=anchor aria-hidden=true href=#replication>#</a></h3><figure><img loading=lazy src=twin.jpeg alt="쌍둥이를 만듭니다." height=500><figcaption><p>쌍둥이를 만듭니다.</p></figcaption></figure><ul><li>동일한 데이터를 가지는 복제 데이터베이스를 생성합니다.</li><li>마스터(master)와 슬레이브(slave)로 구성되어 슬레이브가 마스터의 데이터를 복제하는 방식으로 동작합니다.</li></ul><h3 id=clustering>Clustering<a hidden class=anchor aria-hidden=true href=#clustering>#</a></h3><figure><a href=https://ko.m.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0><img loading=lazy src=cluster.jpeg alt="동일한 작업을 하는 서버를 클러스터로 분리해 가용성을 확보할 수 있습니다."></a><figcaption><p>동일한 작업을 하는 서버를 클러스터로 분리해 가용성을 확보할 수 있습니다.</p></figcaption></figure><ul><li>동일한 작업을 여러 노드를 통해 수행하는 서비스 방식을 말하며, 동일한 업무를 처리해야 하기에 동일한 정보를 가지고 있어야 합니다.</li><li>작업을 분산하거나 동기화하는 과정에서 오버헤드가 발생할 수 있으며, 이러한 작업 스케줄링 및 동기화가 클러스터링에서 해결해야 할 과제입니다.</li></ul><h3 id=shading>Shading<a hidden class=anchor aria-hidden=true href=#shading>#</a></h3><figure><a href=https://techblog.woowahan.com/2687/><img loading=lazy src=sharding.png alt="샤딩은 pk를 분배하는 전략이 중요합니다."></a><figcaption><p>샤딩은 pk를 분배하는 전략이 중요합니다.</p></figcaption></figure><ul><li>하나의 작업을 여러 노드에 분산해서 작업하는 서비스 방식을 말합니다.</li><li>데이터베이스에서는 데이터를 분산해서 저장하는 방식을 말하며, 이렇게 분산 저장된 데이터를 적절하게 인덱싱하는 것이 중요합니다.</li></ul><blockquote><p>Clustering과 헷갈릴 수 있지만, Clustering은 동일한 DB를 여러개 만드는 반면, Shading은 하나의 DB를 쪼개는 방식입니다.
Shading은 수평 분할로, 한 테이블의 행을 여러개의 DB로 분리한다고 생각하며 될 것 같습니다.</p></blockquote><h2 id=cqrs-패턴>CQRS 패턴<a hidden class=anchor aria-hidden=true href=#cqrs-패턴>#</a></h2><p>지금까지 DB 이중화의 목적과 종류에 대해 알아보았는데요, 그럼 CQRS패턴은 무엇일까요?</p><h3 id=정의>정의<a hidden class=anchor aria-hidden=true href=#정의>#</a></h3><p>CQRS<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>패턴은 Command(Create, Update, Delete)와 Query(Read)의 책임을 분리하라는 원칙을 구현한 패턴입니다.</p><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><p>Command와 Query를 분리하는 이유는 다음과 같습니다.</p><ol><li><strong>읽기와 쓰기의 빈도 차이</strong> : 어플리케이션 로직을 생각해보면, 통상 쓰기보다 읽기가 훨씬 많이 발생합니다. Command와 Query를 분리한다면, Query를 수행하는 DB를 Command용 DB보다 많이 생성함으로써 이러한 비율을 맞춰 서비스를 최적화할 수 있습니다.</li><li><strong>확장성</strong> : 위에서 설명한 비율을 고민하며 독립적으로 DB를 확장할 수 있습니다.</li><li><strong>트랜잭션</strong> : Command는 데이터를 변경하기에 트랜잭션이 발생하며, Query는 통상 읽기 전용으로 이루어집니다. 트랜잭션을 처리하는 로직이 분리되면 데이터 변경을 위한 로직을 관리하기 쉬워집니다.</li><li><strong>보안</strong> : 쓰기 권한을 가진 요청을 통해서만 데이터가 변경되는지 확인하기가 용이해집니다.</li></ol><h3 id=구현>구현<a hidden class=anchor aria-hidden=true href=#구현>#</a></h3><p>이러한 CQRS패턴은 어플리케이션 계층에서도 구현할 수 있지만, 데이터베이스를 분리하여 두 작업을 원천 분리할 수 있습니다.</p><p>그 중 대표적인 방법이 위에서 설명했던 Replication을 응용한 방식입니다. Replication은 위에서 설명한 것처럼 Master DB에서 변경된 데이터를 Slave DB에서 그대로 복제하는 특징을 가지고 있습니다.</p><p>따라서 <strong>Command는 Master DB에서 수행하고, Query는 Slave DB에서 수행</strong>하는 방식으로 Command와 Query를 분리할 수 있습니다.</p><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>다양한 이점을 가진 DB 이중화의 다양한 방식을 알아보았고, 이를 통해 CQRS 패턴을 구현할 수 있습니다. 다음 시간부터는 MySQL에서 제공하는 Replication기술을 활용해 SpringBoot Server에서 CQRS패턴을 활용하는 예제를 직접 구현해보겠습니다.</p><blockquote><p>이제야 좀 기술블로그 같은 주제를 다루는 것 같네요. 앞으로도 프로젝트나 다양한 이슈로부터 얻는 노하우와 기술들을 정리해 나가겠습니다.</p></blockquote><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><table><thead><tr><th style=text-align:left>URL</th><th style=text-align:left>게시일자</th><th style=text-align:left>방문일자</th><th style=text-align:left>작성자</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://travislife.tistory.com/29>https://travislife.tistory.com/29</a></td><td style=text-align:left>2020.08.03.</td><td style=text-align:left>2024.03.12.</td><td style=text-align:left>트레비스의 IT라이프</td></tr><tr><td style=text-align:left><a href=https://if.kakao.com/>https://if.kakao.com/</a></td><td style=text-align:left>2022.12.09.</td><td style=text-align:left>2024.03.12.</td><td style=text-align:left>if-kakao-2022</td></tr><tr><td style=text-align:left><a href=https://en.wikipedia.org/wiki/Disaster_recovery>https://en.wikipedia.org/wiki/Disaster_recovery</a></td><td style=text-align:left>2024.03.05.</td><td style=text-align:left>2024.03.12.</td><td style=text-align:left>wikipedia</td></tr><tr><td style=text-align:left><a href=https://techblog.woowahan.com/2687/>https://techblog.woowahan.com/2687/</a></td><td style=text-align:left>2020.07.06.</td><td style=text-align:left>2024.03.12.</td><td style=text-align:left>송재욱, 전병두</td></tr><tr><td style=text-align:left><a href=https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cqrs>https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cqrs</a></td><td style=text-align:left>미등록</td><td style=text-align:left>2024.03.12.</td><td style=text-align:left>Azure Storage</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>개발자 혹은 DB관리자의 실수, 정전, 천재지변, 해커의 공격 등 정말 다양한 원인이 있으며 이러한 모든 원인을 회피하는 것은 불가능합니다. 실제로 <a href=https://www.kakaocorp.com/page/detail/9902>2022년 10월 15일 발생한 카카오 데이터센터 화재</a>로 1개월 이상 복구작업을 하기도 했습니다.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>고가용성 시스템을 추구하는 <a href=https://www.erlang-solutions.com/>Erlang</a> 은 nine nines(99.9999999%)를 달성했다고 하네요.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Command and Query Responsibility Segregation; 명령과 쿼리 분리의 원칙입니다.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://leaf-nam.github.io/tags/replication/>Replication</a></li><li><a href=https://leaf-nam.github.io/tags/architecture/>Architecture</a></li><li><a href=https://leaf-nam.github.io/tags/cqrs/>CQRS</a></li></ul><nav class=paginav><a class=prev href=https://leaf-nam.github.io/posts/cqrs/2/><span class=title>« 이전 페이지</span><br><span>[MySQL]Replication Database 구현</span>
</a><a class=next href=https://leaf-nam.github.io/posts/gitblog/5/><span class=title>다음 페이지 »</span><br><span>깃허브 블로그 댓글 구현 : Utterances 도입기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on x" href="https://x.com/intent/tweet/?text=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1&amp;url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f&amp;hashtags=replication%2carchitecture%2cCQRS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f&amp;title=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1&amp;summary=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1&amp;source=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f&title=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on whatsapp" href="https://api.whatsapp.com/send?text=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1%20-%20https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on telegram" href="https://telegram.me/share/url?text=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1&amp;url=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DB 이중화 및 CQRS 패턴의 중요성 on ycombinator" href="https://news.ycombinator.com/submitlink?t=DB%20%ec%9d%b4%ec%a4%91%ed%99%94%20%eb%b0%8f%20CQRS%20%ed%8c%a8%ed%84%b4%ec%9d%98%20%ec%a4%91%ec%9a%94%ec%84%b1&u=https%3a%2f%2fleaf-nam.github.io%2fposts%2fcqrs%2f1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>