<!doctype html><html lang=ko dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) | 봄을 기다리는 낙엽</title>
<meta name=keywords content><meta name=description content='상황

Windows11 CubeIDE
STM32F429 + FreeRTOS 포팅
context switch(이하 문맥전환) 수업 시간에 각 태스크에서 led를 켜고, delay 시 led를 끄도록 위 코드와 같이 작성함
디버깅 시 첫번째, 두번째 문맥 전환에서는 정상 동작
세번째 문맥 전환 발생 시 Bus Fault 발생

소스 코드
void xPortPendSVHandler( void )
{
   /* This is a naked function. */
   ledoff();

   __asm volatile
   (
   "   mrs r0, psp                     \n"
   "   isb                           \n"
   "                              \n"
   "   ldr   r3, pxCurrentTCBConst         \n" /* Get the location of the current TCB. */
   "   ldr   r2, [r3]                  \n"
   "                              \n"
   "   tst r14, #0x10                  \n" /* Is the task using the FPU context?  If so, push high vfp registers. */
   "   it eq                        \n"
   "   vstmdbeq r0!, {s16-s31}            \n"
   "                              \n"
   "   stmdb r0!, {r4-r11, r14}         \n" /* Save the core registers. */
   "   str r0, [r2]                  \n" /* Save the new top of stack into the first member of the TCB. */
   "                              \n"
   "   stmdb sp!, {r0, r3}               \n"
   "   mov r0, %0                      \n"
   "   msr basepri, r0                  \n"
   "   dsb                           \n"
   "   isb                           \n"
   "   bl vTaskSwitchContext            \n"
   "   mov r0, #0                     \n"
   "   msr basepri, r0                  \n"
   "   ldmia sp!, {r0, r3}               \n"
   "                              \n"
   "   ldr r1, [r3]                  \n" /* The first item in pxCurrentTCB is the task top of stack. */
   "   ldr r0, [r1]                  \n"
   "                              \n"
   "   ldmia r0!, {r4-r11, r14}         \n" /* Pop the core registers. */
   "                              \n"
   "   tst r14, #0x10                  \n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
   "   it eq                        \n"
   "   vldmiaeq r0!, {s16-s31}            \n"
   "                              \n"
   "   msr psp, r0                     \n"
   "   isb                           \n"
   "                              \n"
   #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
      #if WORKAROUND_PMU_CM001 == 1
   "         push { r14 }            \n"
   "         pop { pc }               \n"
      #endif
   #endif
   "                              \n"
   "   bx r14                        \n"
   "                              \n"
   "   .align 4                     \n"
   "pxCurrentTCBConst: .word pxCurrentTCB   \n"
   ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
   );
}
/*-----------------------------------------------------------*/
원인(요약)


xPortPendSVHandler()는 naked 함수로 선언되어 있음'><meta name=author content="map[email:spearoad15@gmail.com name:Sangyeop Nam]"><link rel=canonical href=http://localhost:1313/posts/c/rtos/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.svg><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=http://localhost:1313/posts/c/rtos/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="http://localhost:1313/posts/c/rtos/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS)"><meta property="og:description" content='상황 Windows11 CubeIDE STM32F429 + FreeRTOS 포팅 context switch(이하 문맥전환) 수업 시간에 각 태스크에서 led를 켜고, delay 시 led를 끄도록 위 코드와 같이 작성함 디버깅 시 첫번째, 두번째 문맥 전환에서는 정상 동작 세번째 문맥 전환 발생 시 Bus Fault 발생 소스 코드 void xPortPendSVHandler( void ) { /* This is a naked function. */ ledoff(); __asm volatile ( " mrs r0, psp \n" " isb \n" " \n" " ldr r3, pxCurrentTCBConst \n" /* Get the location of the current TCB. */ " ldr r2, [r3] \n" " \n" " tst r14, #0x10 \n" /* Is the task using the FPU context? If so, push high vfp registers. */ " it eq \n" " vstmdbeq r0!, {s16-s31} \n" " \n" " stmdb r0!, {r4-r11, r14} \n" /* Save the core registers. */ " str r0, [r2] \n" /* Save the new top of stack into the first member of the TCB. */ " \n" " stmdb sp!, {r0, r3} \n" " mov r0, %0 \n" " msr basepri, r0 \n" " dsb \n" " isb \n" " bl vTaskSwitchContext \n" " mov r0, #0 \n" " msr basepri, r0 \n" " ldmia sp!, {r0, r3} \n" " \n" " ldr r1, [r3] \n" /* The first item in pxCurrentTCB is the task top of stack. */ " ldr r0, [r1] \n" " \n" " ldmia r0!, {r4-r11, r14} \n" /* Pop the core registers. */ " \n" " tst r14, #0x10 \n" /* Is the task using the FPU context? If so, pop the high vfp registers too. */ " it eq \n" " vldmiaeq r0!, {s16-s31} \n" " \n" " msr psp, r0 \n" " isb \n" " \n" #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */ #if WORKAROUND_PMU_CM001 == 1 " push { r14 } \n" " pop { pc } \n" #endif #endif " \n" " bx r14 \n" " \n" " .align 4 \n" "pxCurrentTCBConst: .word pxCurrentTCB \n" ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY) ); } /*-----------------------------------------------------------*/ 원인(요약) xPortPendSVHandler()는 naked 함수로 선언되어 있음'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-11T10:27:45+09:00"><meta property="article:modified_time" content="2026-02-11T10:27:45+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS)"><meta name=twitter:description content='상황

Windows11 CubeIDE
STM32F429 + FreeRTOS 포팅
context switch(이하 문맥전환) 수업 시간에 각 태스크에서 led를 켜고, delay 시 led를 끄도록 위 코드와 같이 작성함
디버깅 시 첫번째, 두번째 문맥 전환에서는 정상 동작
세번째 문맥 전환 발생 시 Bus Fault 발생

소스 코드
void xPortPendSVHandler( void )
{
   /* This is a naked function. */
   ledoff();

   __asm volatile
   (
   "   mrs r0, psp                     \n"
   "   isb                           \n"
   "                              \n"
   "   ldr   r3, pxCurrentTCBConst         \n" /* Get the location of the current TCB. */
   "   ldr   r2, [r3]                  \n"
   "                              \n"
   "   tst r14, #0x10                  \n" /* Is the task using the FPU context?  If so, push high vfp registers. */
   "   it eq                        \n"
   "   vstmdbeq r0!, {s16-s31}            \n"
   "                              \n"
   "   stmdb r0!, {r4-r11, r14}         \n" /* Save the core registers. */
   "   str r0, [r2]                  \n" /* Save the new top of stack into the first member of the TCB. */
   "                              \n"
   "   stmdb sp!, {r0, r3}               \n"
   "   mov r0, %0                      \n"
   "   msr basepri, r0                  \n"
   "   dsb                           \n"
   "   isb                           \n"
   "   bl vTaskSwitchContext            \n"
   "   mov r0, #0                     \n"
   "   msr basepri, r0                  \n"
   "   ldmia sp!, {r0, r3}               \n"
   "                              \n"
   "   ldr r1, [r3]                  \n" /* The first item in pxCurrentTCB is the task top of stack. */
   "   ldr r0, [r1]                  \n"
   "                              \n"
   "   ldmia r0!, {r4-r11, r14}         \n" /* Pop the core registers. */
   "                              \n"
   "   tst r14, #0x10                  \n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
   "   it eq                        \n"
   "   vldmiaeq r0!, {s16-s31}            \n"
   "                              \n"
   "   msr psp, r0                     \n"
   "   isb                           \n"
   "                              \n"
   #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
      #if WORKAROUND_PMU_CM001 == 1
   "         push { r14 }            \n"
   "         pop { pc }               \n"
      #endif
   #endif
   "                              \n"
   "   bx r14                        \n"
   "                              \n"
   "   .align 4                     \n"
   "pxCurrentTCBConst: .word pxCurrentTCB   \n"
   ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
   );
}
/*-----------------------------------------------------------*/
원인(요약)


xPortPendSVHandler()는 naked 함수로 선언되어 있음'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS)","item":"http://localhost:1313/posts/c/rtos/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS)","name":"Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 \u002b FreeRTOS)","description":"상황 Windows11 CubeIDE STM32F429 + FreeRTOS 포팅 context switch(이하 문맥전환) 수업 시간에 각 태스크에서 led를 켜고, delay 시 led를 끄도록 위 코드와 같이 작성함 디버깅 시 첫번째, 두번째 문맥 전환에서는 정상 동작 세번째 문맥 전환 발생 시 Bus Fault 발생 소스 코드 void xPortPendSVHandler( void ) { /* This is a naked function. */ ledoff(); __asm volatile ( \u0026#34; mrs r0, psp \\n\u0026#34; \u0026#34; isb \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; ldr r3, pxCurrentTCBConst \\n\u0026#34; /* Get the location of the current TCB. */ \u0026#34; ldr r2, [r3] \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; tst r14, #0x10 \\n\u0026#34; /* Is the task using the FPU context? If so, push high vfp registers. */ \u0026#34; it eq \\n\u0026#34; \u0026#34; vstmdbeq r0!, {s16-s31} \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; stmdb r0!, {r4-r11, r14} \\n\u0026#34; /* Save the core registers. */ \u0026#34; str r0, [r2] \\n\u0026#34; /* Save the new top of stack into the first member of the TCB. */ \u0026#34; \\n\u0026#34; \u0026#34; stmdb sp!, {r0, r3} \\n\u0026#34; \u0026#34; mov r0, %0 \\n\u0026#34; \u0026#34; msr basepri, r0 \\n\u0026#34; \u0026#34; dsb \\n\u0026#34; \u0026#34; isb \\n\u0026#34; \u0026#34; bl vTaskSwitchContext \\n\u0026#34; \u0026#34; mov r0, #0 \\n\u0026#34; \u0026#34; msr basepri, r0 \\n\u0026#34; \u0026#34; ldmia sp!, {r0, r3} \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; ldr r1, [r3] \\n\u0026#34; /* The first item in pxCurrentTCB is the task top of stack. */ \u0026#34; ldr r0, [r1] \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; ldmia r0!, {r4-r11, r14} \\n\u0026#34; /* Pop the core registers. */ \u0026#34; \\n\u0026#34; \u0026#34; tst r14, #0x10 \\n\u0026#34; /* Is the task using the FPU context? If so, pop the high vfp registers too. */ \u0026#34; it eq \\n\u0026#34; \u0026#34; vldmiaeq r0!, {s16-s31} \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; msr psp, r0 \\n\u0026#34; \u0026#34; isb \\n\u0026#34; \u0026#34; \\n\u0026#34; #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */ #if WORKAROUND_PMU_CM001 == 1 \u0026#34; push { r14 } \\n\u0026#34; \u0026#34; pop { pc } \\n\u0026#34; #endif #endif \u0026#34; \\n\u0026#34; \u0026#34; bx r14 \\n\u0026#34; \u0026#34; \\n\u0026#34; \u0026#34; .align 4 \\n\u0026#34; \u0026#34;pxCurrentTCBConst: .word pxCurrentTCB \\n\u0026#34; ::\u0026#34;i\u0026#34;(configMAX_SYSCALL_INTERRUPT_PRIORITY) ); } /*-----------------------------------------------------------*/ 원인(요약) xPortPendSVHandler()는 naked 함수로 선언되어 있음\n","keywords":[],"articleBody":"상황 Windows11 CubeIDE STM32F429 + FreeRTOS 포팅 context switch(이하 문맥전환) 수업 시간에 각 태스크에서 led를 켜고, delay 시 led를 끄도록 위 코드와 같이 작성함 디버깅 시 첫번째, 두번째 문맥 전환에서는 정상 동작 세번째 문맥 전환 발생 시 Bus Fault 발생 소스 코드 void xPortPendSVHandler( void ) { /* This is a naked function. */ ledoff(); __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\" /* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" tst r14, #0x10 \\n\" /* Is the task using the FPU context? If so, push high vfp registers. */ \" it eq \\n\" \" vstmdbeq r0!, {s16-s31} \\n\" \" \\n\" \" stmdb r0!, {r4-r11, r14} \\n\" /* Save the core registers. */ \" str r0, [r2] \\n\" /* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r0, r3} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" dsb \\n\" \" isb \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r0, r3} \\n\" \" \\n\" \" ldr r1, [r3] \\n\" /* The first item in pxCurrentTCB is the task top of stack. */ \" ldr r0, [r1] \\n\" \" \\n\" \" ldmia r0!, {r4-r11, r14} \\n\" /* Pop the core registers. */ \" \\n\" \" tst r14, #0x10 \\n\" /* Is the task using the FPU context? If so, pop the high vfp registers too. */ \" it eq \\n\" \" vldmiaeq r0!, {s16-s31} \\n\" \" \\n\" \" msr psp, r0 \\n\" \" isb \\n\" \" \\n\" #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */ #if WORKAROUND_PMU_CM001 == 1 \" push { r14 } \\n\" \" pop { pc } \\n\" #endif #endif \" \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\"(configMAX_SYSCALL_INTERRUPT_PRIORITY) ); } /*-----------------------------------------------------------*/ 원인(요약) xPortPendSVHandler()는 naked 함수로 선언되어 있음\n해당 함수 상단에서 ledoff()라는 일반 C 함수 호출\n이 과정에서 LR(r14) 값이 오염\n오염된 LR 값이 TCB에 저장되고, 이후 복귀 과정에서 사용되면서 Fault 발생\n상세분석 다양한 원인이 함께 연관되어 발생한 문제이므로, 각각의 상황을 상세히 분석해 보겠습니다.\nSTM32의 ISR(인터럽트 서비스 루틴) 인터럽트 진입 시, Cortex-M 하드웨어는 다음을 자동으로 수행 LR에 EXC_RETURN 값 저장\n스택에 스택 프레임 저장\n스택 프레임 구성 // 1 R0 ~ R3 // 2 R12 // 3 LR // 4 PC // 5 xPSR 인터럽트 복귀 시 LR의 EXC_RETURN 값과 스택 프레임에 저장된 PC 값 확인\n복귀 모드 및 복귀 주소를 결정하여 복귀 수행\n위 과정은 하드웨어에 의해 자동으로 처리됩니다.\ncontext switching(문맥 전환) FreeRTOS의 context switch는 위 하드웨어 스택 프레임과 별도로 태스크의 실행 상태를 저장해야 합니다.\n이를 위해 다음 레지스터를 소프트웨어적으로 저장합니다.\nR4 ~ R11 R14 (LR) 이는 태스크가 중단된 시점의 상태를 유지하기 위함입니다.\n문맥 전환 후, 새로운 TCB + 기존 레지스터 값 활용해서 새로운 태스크로 복귀합니다. naked 함수 assembly코드를 직접 사용하기 위해 프로토타입에 다음과 같이 선언합니다. void xPortPendSVHandler( void ) __attribute__ (( naked )); naked 함수의 특징 컴파일러가 함수 프롤로그 / 에필로그를 생성하지 않음 스택 프레임 자동 저장/복원이 이루어지지 않음 레지스터 보존에 대한 ABI 보장이 없음 PendSV(문맥 전환용 인터럽트) 핸들러는 직접 레지스터를 제어해야 하므로 naked 함수로 구현됩니다.\nassembly 분석 분석에 불필요한 값은 생략했습니다. 사실 영문 주석으로 잘 달려있긴 합니다.\n/* 문맥 전환 전 현재 레지스터의 상태를 메모리와 기존 TCB에 저장 */ \" stmdb r0!, {r4-r11, r14} \\n\" /* Save the core registers. */ \" str r0, [r2] \\n\" /* Save the new top of stack into the first member of the TCB. */ /* 문맥 전환(가장 우선순위 높은 Task 가져옴) */ \" bl vTaskSwitchContext \\n\" /* 문맥 전환 후 새로운 TCB를 가져옴 */ \" ldr r1, [r3] \\n\" /* The first item in pxCurrentTCB is the task top of stack. */ /* 새로운 TCB의 주소로 복귀 */ \" bx r14 \\n\" 문제 상황 재정리 원래 상황으로 돌아가서, 위 코드 맨위에 다른 함수를 호출한 경우를 보겠습니다. void xPortPendSVHandler( void ) { // 함수가 처음 호출되면 LR에 EXC_RETURN(0xFFFFFFF5) 저장 // 다른 함수 호출된 후 복귀되면서 LR에 ledoff()의 복귀 주소가 저장(오염) ledoff(); /* 문맥 전환 전 현재 레지스터의 상태를 메모리와 기존 TCB에 저장 =\u003e r14에 EXC_RETURN이 아닌 주소값 저장 */ \" stmdb r0!, {r4-r11, r14} \\n\" \" str r0, [r2] \\n\" /* 문맥 전환(가장 우선순위 높은 Task 가져옴) */ \" bl vTaskSwitchContext \\n\" /* 문맥 전환 후 새로운 TCB를 가져옴 =\u003e 첫번째 호출시에는 EXC_RETURN 정상적으로 가져옴, 두번째 호출부터 복귀주소(오염된 값) 가져옴 */ \" ldr r1, [r3] \\n\" /* 새로운 TCB의 주소로 복귀 */ \" bx r14 \\n\" } 첫 번째 문맥 전환\n오염된 태스크로 아직 복귀하지 않으므로 정상 동작 두 번째 문맥 전환 시 오염된 LR 값을 가진 태스크로 복귀 시도\nEXC_RETURN 규칙에 맞지 않는 값 사용 Bus Fault 발생 결론 ISR + naked + context switch라는 특수한 상황 조건이 겹쳐서 발생한 오류였습니다. | STM32의 문맥 전환을 전반적으로 이해할 수 있는 좋은 예제인 것 같습니다. naked가 선언된 곳에는 절대 C 함수를 호출하지 말자!\n","wordCount":"815","inLanguage":"ko","datePublished":"2026-02-11T10:27:45+09:00","dateModified":"2026-02-11T10:27:45+09:00","author":{"@type":"Person","name":{"email":"spearoad15@gmail.com","name":"Sangyeop Nam"}},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/c/rtos/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title=검색><span>검색</span></a></li><li><a href=http://localhost:1313/posts/ title=게시글><span>게시글</span></a></li><li><a href=http://localhost:1313/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=http://localhost:1313/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=http://localhost:1313/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=http://localhost:1313/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=http://localhost:1313/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=http://localhost:1313/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>홈</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS)</h1><div class=post-meta><span title='2026-02-11 10:27:45 +0900 KST'>2026. 2. 11.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;815 단어&nbsp;·&nbsp;map[email:spearoad15@gmail.com name:Sangyeop Nam]&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content/posts/c/rtos/index.md rel="noopener noreferrer" target=_blank>Source Page</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#상황>상황</a><ul><li><a href=#소스-코드>소스 코드</a></li></ul></li><li><a href=#원인요약>원인(요약)</a></li><li><a href=#상세분석>상세분석</a><ul><li><a href=#stm32의-isr인터럽트-서비스-루틴>STM32의 ISR(인터럽트 서비스 루틴)</a></li><li><a href=#context-switching문맥-전환>context switching(문맥 전환)</a></li><li><a href=#naked-함수>naked 함수</a></li><li><a href=#assembly-분석>assembly 분석</a></li><li><a href=#문제-상황-재정리>문제 상황 재정리</a></li></ul></li><li><a href=#결론>결론</a></li></ul></nav></div></details></div><div class=post-content><h2 id=상황>상황<a hidden class=anchor aria-hidden=true href=#상황>#</a></h2><ul><li>Windows11 CubeIDE</li><li>STM32F429 + FreeRTOS 포팅</li><li>context switch(이하 문맥전환) 수업 시간에 각 태스크에서 led를 켜고, delay 시 led를 끄도록 위 코드와 같이 작성함</li><li>디버깅 시 <code>첫번째, 두번째 문맥 전환</code>에서는 정상 동작</li><li><code>세번째 문맥 전환 발생 시</code> Bus Fault 발생</li></ul><h3 id=소스-코드>소스 코드<a hidden class=anchor aria-hidden=true href=#소스-코드>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xPortPendSVHandler</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=cm>/* This is a naked function. */</span>
</span></span><span class=line><span class=cl>   <span class=nf>ledoff</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=kr>__asm</span> <span class=k>volatile</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   mrs r0, psp                     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   isb                           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldr   r3, pxCurrentTCBConst         </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Get the location of the current TCB. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldr   r2, [r3]                  </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   tst r14, #0x10                  </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Is the task using the FPU context?  If so, push high vfp registers. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   it eq                        </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   vstmdbeq r0!, {s16-s31}            </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   stmdb r0!, {r4-r11, r14}         </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Save the core registers. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   str r0, [r2]                  </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Save the new top of stack into the first member of the TCB. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   stmdb sp!, {r0, r3}               </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   mov r0, %0                      </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   msr basepri, r0                  </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   dsb                           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   isb                           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   bl vTaskSwitchContext            </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   mov r0, #0                     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   msr basepri, r0                  </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldmia sp!, {r0, r3}               </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldr r1, [r3]                  </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* The first item in pxCurrentTCB is the task top of stack. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldr r0, [r1]                  </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldmia r0!, {r4-r11, r14}         </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Pop the core registers. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   tst r14, #0x10                  </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Is the task using the FPU context?  If so, pop the high vfp registers too. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   it eq                        </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   vldmiaeq r0!, {s16-s31}            </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   msr psp, r0                     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   isb                           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=cp>#ifdef WORKAROUND_PMU_CM001 </span><span class=cm>/* XMC4000 specific errata workaround. */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=cp>#if WORKAROUND_PMU_CM001 == 1
</span></span></span><span class=line><span class=cl><span class=cp></span>   <span class=s>&#34;         push { r14 }            </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;         pop { pc }               </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>      <span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>   <span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   bx r14                        </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;                              </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   .align 4                     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;pxCurrentTCBConst: .word pxCurrentTCB   </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=o>::</span><span class=s>&#34;i&#34;</span><span class=p>(</span><span class=n>configMAX_SYSCALL_INTERRUPT_PRIORITY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*-----------------------------------------------------------*/</span>
</span></span></code></pre></div><h2 id=원인요약>원인(요약)<a hidden class=anchor aria-hidden=true href=#원인요약>#</a></h2><ul><li><p>xPortPendSVHandler()는 <code>naked 함수</code>로 선언되어 있음</p></li><li><p>해당 함수 상단에서 ledoff()라는 <code>일반 C 함수 호출</code></p></li><li><p>이 과정에서 <code>LR(r14) 값이 오염</code></p></li><li><p><code>오염된 LR 값이 TCB에 저장</code>되고, 이후 복귀 과정에서 사용되면서 Fault 발생</p></li></ul><h2 id=상세분석>상세분석<a hidden class=anchor aria-hidden=true href=#상세분석>#</a></h2><blockquote><p>다양한 원인이 함께 연관되어 발생한 문제이므로, 각각의 상황을 상세히 분석해 보겠습니다.</p></blockquote><h3 id=stm32의-isr인터럽트-서비스-루틴>STM32의 ISR(인터럽트 서비스 루틴)<a hidden class=anchor aria-hidden=true href=#stm32의-isr인터럽트-서비스-루틴>#</a></h3><ul><li>인터럽트 진입 시, Cortex-M 하드웨어는 다음을 자동으로 수행</li></ul><ol><li><p>LR에 <code>EXC_RETURN</code> 값 저장</p></li><li><p>스택에 <code>스택 프레임</code> 저장</p></li></ol><ul><li>스택 프레임 구성</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 1 R0 ~ R3
</span></span></span><span class=line><span class=cl><span class=c1>// 2 R12
</span></span></span><span class=line><span class=cl><span class=c1>// 3 LR
</span></span></span><span class=line><span class=cl><span class=c1>// 4 PC
</span></span></span><span class=line><span class=cl><span class=c1>// 5 xPSR
</span></span></span></code></pre></div><ol start=3><li><p>인터럽트 복귀 시 <code>LR의 EXC_RETURN</code> 값과 <code>스택 프레임</code>에 저장된 PC 값 확인</p></li><li><p>복귀 모드 및 복귀 주소를 결정하여 복귀 수행</p></li></ol><blockquote><p>위 과정은 <code>하드웨어에 의해 자동</code>으로 처리됩니다.</p></blockquote><h3 id=context-switching문맥-전환>context switching(문맥 전환)<a hidden class=anchor aria-hidden=true href=#context-switching문맥-전환>#</a></h3><ul><li><p>FreeRTOS의 context switch는 위 하드웨어 스택 프레임과 별도로 태스크의 실행 상태를 저장해야 합니다.</p></li><li><p>이를 위해 <code>다음 레지스터를 소프트웨어적으로 저장</code>합니다.</p><ul><li><code>R4 ~ R11</code></li><li><code>R14 (LR)</code></li></ul></li></ul><blockquote><p>이는 태스크가 중단된 시점의 상태를 유지하기 위함입니다.</p></blockquote><ul><li>문맥 전환 후, 새로운 TCB + 기존 레지스터 값 활용해서 새로운 태스크로 복귀합니다.</li></ul><h3 id=naked-함수>naked 함수<a hidden class=anchor aria-hidden=true href=#naked-함수>#</a></h3><ul><li>assembly코드를 직접 사용하기 위해 프로토타입에 다음과 같이 선언합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xPortPendSVHandler</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span> <span class=nf>__attribute__</span> <span class=p>((</span> <span class=kr>naked</span> <span class=p>));</span>
</span></span></code></pre></div><ul><li><strong>naked 함수의 특징</strong><ul><li>컴파일러가 함수 <code>프롤로그 / 에필로그</code>를 생성하지 않음</li><li>스택 프레임 자동 저장/복원이 이루어지지 않음</li><li>레지스터 보존에 대한 ABI 보장이 없음</li></ul></li></ul><blockquote><p>PendSV(문맥 전환용 인터럽트) 핸들러는 <code>직접 레지스터를 제어</code>해야 하므로 naked 함수로 구현됩니다.</p></blockquote><h3 id=assembly-분석>assembly 분석<a hidden class=anchor aria-hidden=true href=#assembly-분석>#</a></h3><blockquote><p>분석에 불필요한 값은 생략했습니다. 사실 영문 주석으로 잘 달려있긴 합니다.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 문맥 전환 전 현재 레지스터의 상태를 메모리와 기존 TCB에 저장 */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   stmdb r0!, {r4-r11, r14}      </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Save the core registers. */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   str r0, [r2]                  </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Save the new top of stack into the first member of the TCB. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 문맥 전환(가장 우선순위 높은 Task 가져옴) */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   bl vTaskSwitchContext         </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 문맥 전환 후 새로운 TCB를 가져옴 */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldr r1, [r3]                  </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* The first item in pxCurrentTCB is the task top of stack. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 새로운 TCB의 주소로 복귀 */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   bx r14                        </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span></code></pre></div><h3 id=문제-상황-재정리>문제 상황 재정리<a hidden class=anchor aria-hidden=true href=#문제-상황-재정리>#</a></h3><ul><li>원래 상황으로 돌아가서, 위 코드 맨위에 다른 함수를 호출한 경우를 보겠습니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xPortPendSVHandler</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>   <span class=c1>// 함수가 처음 호출되면 LR에 EXC_RETURN(0xFFFFFFF5) 저장
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>   <span class=c1>// 다른 함수 호출된 후 복귀되면서 LR에 ledoff()의 복귀 주소가 저장(오염)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>ledoff</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 문맥 전환 전 현재 레지스터의 상태를 메모리와 기존 TCB에 저장
</span></span></span><span class=line><span class=cl><span class=cm>        =&gt; r14에 EXC_RETURN이 아닌 주소값 저장 */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   stmdb r0!, {r4-r11, r14}         </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   str r0, [r2]                     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 문맥 전환(가장 우선순위 높은 Task 가져옴) */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   bl vTaskSwitchContext            </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 문맥 전환 후 새로운 TCB를 가져옴
</span></span></span><span class=line><span class=cl><span class=cm>         =&gt; 첫번째 호출시에는 EXC_RETURN 정상적으로 가져옴, 두번째 호출부터 복귀주소(오염된 값) 가져옴 */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   ldr r1, [r3]                     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* 새로운 TCB의 주소로 복귀 */</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;   bx r14                           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p>첫 번째 문맥 전환</p><ul><li>오염된 태스크로 아직 복귀하지 않으므로 정상 동작</li></ul></li><li><p>두 번째 문맥 전환 시 <code>오염된 LR 값을 가진 태스크로 복귀</code> 시도</p><ul><li>EXC_RETURN 규칙에 맞지 않는 값 사용</li><li>Bus Fault 발생</li></ul></li></ul><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><ul><li><code>ISR</code> + <code>naked</code> + <code>context switch</code>라는 특수한 상황 조건이 겹쳐서 발생한 오류였습니다.
| STM32의 문맥 전환을 전반적으로 이해할 수 있는 좋은 예제인 것 같습니다.</li></ul><blockquote><p>naked가 선언된 곳에는 <strong><code>절대 C 함수를 호출하지 말자!</code></strong></p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/gitblog/1/><span class=title>« 이전 페이지</span><br><span>개발 블로그의 종류와 선택</span>
</a><a class=next href=http://localhost:1313/cote/programmers_214289/><span class=title>다음 페이지 »</span><br><span>[Java]Programmers 에어컨</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on x" href="https://x.com/intent/tweet/?text=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f&amp;title=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29&amp;summary=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f&title=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on whatsapp" href="https://api.whatsapp.com/send?text=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on telegram" href="https://telegram.me/share/url?text=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Context Switch 중 Bus Fault 발생 원인 분석(STM32F429 + FreeRTOS) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Context%20Switch%20%ec%a4%91%20Bus%20Fault%20%eb%b0%9c%ec%83%9d%20%ec%9b%90%ec%9d%b8%20%eb%b6%84%ec%84%9d%28STM32F429%20%2b%20FreeRTOS%29&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2frtos%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>