<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JPA Cascade vs Orphan Removal | 봄을 기다리는 낙엽</title>
<meta name=keywords content="concept,JPA,Hibernate"><meta name=description content="Cascade의 개념 차이에 대해 정리합니다."><meta name=author content="Leaf"><link rel=canonical href=https://leaf-nam.github.io/tips/240513/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/tips/240513/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/tips/240513/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="JPA Cascade vs Orphan Removal"><meta property="og:description" content="Cascade의 개념 차이에 대해 정리합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="tips"><meta property="article:published_time" content="2024-05-13T21:01:16+09:00"><meta property="article:modified_time" content="2024-05-13T21:01:16+09:00"><meta property="article:tag" content="Concept"><meta property="article:tag" content="JPA"><meta property="article:tag" content="Hibernate"><meta name=twitter:card content="summary"><meta name=twitter:title content="JPA Cascade vs Orphan Removal"><meta name=twitter:description content="Cascade의 개념 차이에 대해 정리합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"작고 소중한 미세팁들","item":"https://leaf-nam.github.io/tips/"},{"@type":"ListItem","position":2,"name":"JPA Cascade vs Orphan Removal","item":"https://leaf-nam.github.io/tips/240513/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JPA Cascade vs Orphan Removal","name":"JPA Cascade vs Orphan Removal","description":"Cascade의 개념 차이에 대해 정리합니다.","keywords":["concept","JPA","Hibernate"],"articleBody":"개요 프로젝트를 하던 중, 엔티티 연관관계에서 cascade를 잘못 사용하여 잘못된 엔티티가 삭제되었고, 테스트가 실패하는 상황이 발생했습니다.\n동일한 실수를 반복하지 않도록, 이번 기회에 JPA Cascade 개념과 Orphan Removal과는 어떠한 차이가 있는지 확인해보겠습니다.\nJPA(Hibernate) Cascade 먼저 Java EE 6의 가이드에는 다음과 같이 명시되어 있습니다.\nJava EE6 가이드의 CASCADE 설명\n설명을 읽어보면 Cascade는 영속성 컨텍스트(Persistence Context)에 부모(Cascade옵션을 작성하는 엔티티)가 특정 작업을 수행할 때, 연관된 엔티티(이후 자식이라고 하겠습니다)도 같은 작업을 수행해야 함을 명시하고 있습니다.\n자세한 내용은 Hibernate의 공식문서1 를 살펴보면 더욱 이해하기 좋은 것 같습니다.\n위 문서의 본문 예시를 참조하면 각 옵션의 주요 기능을 알 수 있습니다.2\n1. ALL 아래 모든 기능들을 포함하는 속성입니다. @Entity public class Person { @Id private Long id; private String name; // Cascade가 All로 설정되어 모든 옵션이 적용되어 있습니다. @OneToMany(mappedBy = \"owner\", cascade = CascadeType.ALL) private List\u003cPhone\u003e phones = new ArrayList\u003c\u003e(); // Getter, Setter 생략 public void addPhone(Phone phone) { this.phones.add(phone); phone.setOwner(this); } } @Entity public class Phone { @Id private Long id; @Column(name = \"`number`\") private String number; @ManyToOne(fetch = FetchType.LAZY) private Person owner; // Getter, Setter 생략 } 2. PERSIST3 DB에 저장될 때 자식을 함께 저장합니다. // given : Person과 phone 엔티티 생성 및 등록 Person person = new Person(); person.setId(1L); person.setName(\"John Doe\"); Phone phone = new Phone(); phone.setId(1L); phone.setNumber(\"123-456-7890\"); person.addPhone(phone); // when : person 저장 entityManager.persist(person); // then : 다음과 같이 2개의 Insert 쿼리가 나가면서 연관된 자식을 함께 저장합니다. INSERT INTO Person(name, id) VALUES( 'John Doe',1) INSERT INTO Phone( `number`, person_id, id) VALUES( '123-456-7890',1,1) 3. MERGE4 부모의 상태를 병합할 때, 자동으로 자식의 상태를 함께 확인해서 병합합니다. // given : DB에서 엔티티 조회, 변경사항 생성 후 영속성 컨텍스트를 clear() -\u003e 엔티티 분리 Phone phone = entityManager.find(Phone.class, 1L); Person person = phone.getOwner(); person.setName(\"John Doe Jr.\"); phone.setNumber(\"987-654-3210\"); entityManager.clear(); // when : person 병합(merge) entityManager.merge(person); // then : 객체를 채우기 위해 다음과 같이 자동으로 Fetch Join이 나가서 자식 엔티티의 값을 채웁니다. SELECT p.id as id1_0_1_, p.name as name2_0_1_, ph.owner_id as owner_id3_1_3_, ph.id as id1_1_3_, ph.id as id1_1_0_, ph.\"number\" as number2_1_0_, ph.owner_id as owner_id3_1_0_ FROM Person p LEFT OUTER JOIN Phone ph on p.id=ph.owner_id WHERE p.id = 1 4. REMOVE 부모가 삭제될 떄 자식을 함께 삭제합니다. 참고로 Hibernate에는 DELETE라는 속성도 있는데 같은 동작이라고 합니다. // given : person을 불러오기 Person person = entityManager.find(Person.class, 1L); // when : person 삭제 entityManager.remove(person); // then : 부모가 삭제되기 전 자식을 먼저 삭제합니다. DELETE FROM Phone WHERE id = 1 DELETE FROM Person WHERE id = 1 5. DETACH5 부모가 분리될 때, 자식도 함께 분리합니다. // given : person을 불러오기 Person person = entityManager.find(Person.class, 1L); Phone phone = person.getPhones().get(0); assertTrue(entityManager.contains(person)); assertTrue(entityManager.contains(phone)); // when : 영속성 컨텍스트에서 Person을 분리할 경우, entityManager.detach(person); // then : 부모가 컨텍스트에서 분리될 떄, 자식도 함께 분리합니다. assertFalse(entityManager.contains(person)); assertFalse(entityManager.contains(phone)); 6. Hibernate 추가 명세 Hibernate에서는 추가로 LOCK, REFRESH, REPLICATE 세가지 옵션을 더 지원합니다. Session에서 사용하는 위 세가지 메서드의 편의를 제공하기 위함입니다. CascadeType.LOCK6\n부모 조회 시 Lock이 될때 자식도 lock에 걸릴 것 같지만, 그렇게 동작하지는 않는다고 합니다.7 Lock 옵션을 적용하여 부모를 영속성 컨텍스트에 다시 불러오면(reattach), 자식도 함께 불러오는 옵션입니다. 아래 예시에서 session8의 Lock() 메서드를 통해 부모를 조회하면 자식 또한 함께 조회되는 것을 볼 수 있습니다. // given : person을 불러오기 Person person = entityManager.find(Person.class, 1L); assertEquals(1, person.getPhones().size()); Phone phone = person.getPhones().get(0); assertTrue(entityManager.contains(person)); assertTrue(entityManager.contains(phone)); // when : 부모 분리 후 lock메서드를 통해 session을 다시 불러올 경우 entityManager.detach(person); assertFalse(entityManager.contains(person)); assertFalse(entityManager.contains(phone)); entityManager.unwrap(Session.class) .lock(person, new LockOptions(LockMode.NONE)); // then : 부모, 자식 한번에 조회 assertTrue(entityManager.contains(person)); assertTrue(entityManager.contains(phone)); CascadeType.REFRESH9\n부모가 새로고침(Refresh) 될 때, 자식도 함께 새로고침하는 옵션입니다. 정합성 보장을 위해 DB와 영속성 컨텍스트를 일치화 후 작업해야 할 때 유용할 것 같습니다. // given : person을 불러오기 Person person = entityManager.find(Person.class, 1L); Phone phone = person.getPhones().get(0); // when : 엔티티 값 변경 후 새로고침하기 person.setName(\"John Doe Jr.\"); phone.setNumber(\"987-654-3210\"); entityManager.refresh(person); // then : 변경사항이 반영되지 않고, DB에 있는 값이 그대로 적용됨 assertEquals(\"John Doe\", person.getName()); assertEquals(\"123-456-7890\", phone.getNumber()); CascadeType.REPLICATE10\n부모가 다른 데이터소스를 수정할 때, 자식도 함께 수정하는 옵션입니다. CQRS 분리나 Scale Out등을 위해 여러 데이터소스를 함께 사용한다면 유용할 것 같습니다. // given : person과 phone 생성(저장하지 않은 상태) Person person = new Person(); person.setId(1L); person.setName(\"John Doe Sr.\"); Phone phone = new Phone(); phone.setId(1L); phone.setNumber(\"(01) 123-456-7890\"); person.addPhone(phone); // when : 다른 데이터소스에 있는 값 덮어쓰기 entityManager.unwrap(Session.class).replicate(person, ReplicationMode.OVERWRITE); // then : 다음과 같이 자동으로 다른 데이터소스를 수정하는 쿼리가 나갑니다. SELECT id FROM Person WHERE id = 1 SELECT id FROM Phone WHERE id = 1 UPDATE Person SET name = 'John Doe Sr.' WHERE id = 1 UPDATE Phone SET \"number\" = '(01) 123-456-7890', owner_id = 1 WHERE id = 1 지금까지 JPA와 Hibernate의 Cascade 옵션에 대해 알아보았습니다. 결국 영속성 컨텍스트에 부모-자식 엔티티를 한번에 불러오거나 생성, 변경, 삭제하는 옵션이라고 할 수 있겠습니다.\nOrphan Removal 다음은 Orphan Removal 옵션입니다.\n해당 옵션에 대한 설명은 JPA 기본 명세 45p에 잘 나와있습니다.(GPT 3.5 번역)\n일대일(OneToOne) 또는 일대다(OneToMany)로 지정된 연관 관계는 orphanRemoval 옵션을 사용할 수 있습니다. orphanRemoval이 적용될 때 다음과 같은 동작이 발생합니다:\n연관 관계의 대상이 되는 엔터티가 연관 관계에서 제거되면(예: 연관 관계를 null로 설정하거나 연관 관계 컬렉션에서 엔터티를 제거함으로써), 고아가 된 엔터티에 대해 삭제 작업이 적용됩니다. 삭제 작업은 플러시(flush) 작업 시점에 적용됩니다. orphanRemoval 기능은 부모 엔터티에 의해 개인적으로 “소유\"되는 엔터티를 위해 의도된 것입니다. 이 기능을 사용할 경우, 응용 프로그램은 특정한 제거 순서에 의존해서는 안 되며, 고아가 된 엔터티를 다른 연관 관계에 재할당하거나 해당 엔터티를 지속(persist)하려고 시도해서는 안 됩니다. 고아가 된 엔터티가 분리(detached) 상태이거나, 새로 생성된 상태이거나, 삭제된 상태인 경우, orphanRemoval의 의미는 적용되지 않습니다.\n관리되는 소스 엔터티에 대해 삭제 작업이 적용되면, 삭제 작업은 섹션 3.2.311의 규칙에 따라 연관 관계의 대상 엔터티에 전파됩니다(따라서 연관 관계에 대해 cascade=REMOVE를 명시할 필요는 없습니다).\n즉, 일대일 또는 일대다 연관관계에서 부모 엔티티의 참조가 사라지면, 영속성 컨텍스트를 flush하는 시점에 자식 엔티티를 삭제합니다.\n또한, 부모 엔티티를 삭제하면 자동으로 cascade=REMOVE를 적용한 것과 같이 자식을 삭제하는 효과도 줍니다.\n// given : person을 불러오기 Person person = entityManager.find(Person.class, 1L); Phone phone = person.getPhones().get(0); assertEquals(phone.getId(), 1); // when : person에서 phone 참조값 제거 후 flush person.getPhones().set(0, null); entityManager.flush(); // then : 참조가 사라진 자식(고아) 엔티티를 삭제합니다. DELETE FROM Phone WHERE id = 1 결론 제가 잘못 이해하고 있던 부분은 CascadeType.REMOVE는 삭제되는게 아니라 영속성 컨텍스트에서 분리될 때 함께 분리된다고 생각한 점이었습니다(이 기능은 CascadeType.DETACH와 헷갈렸던 것 같습니다.). 사실 Orphan Removal과 CascadeType.REMOVE는 기능적으로는 동일하지만, REMOVE는 삭제(EntityManager.remove())를 명시할때만 발동되는 반면 Orphan Removal은 삭제 뿐 아니라 null이나 참조값 변경 등으로 참조가 없어질 때에도 삭제하는 것이 가장 큰 차이인 것 같습니다. 두루뭉실하게 알고 있던 지식들이 공식문서를 통해 접하니 좀더 확실하게 알게 된 느낌입니다. 앞으로도 잘 모르겠다 싶으면 공식문서를 참고하는 습관을 들여야겠습니다.\nReferences URL 게시일자 방문일자 작성자 https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html#gjjnj 2013. 2024.05.13. Oracle https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html 2024.05.03. 2024.05.13. Hibernate https://download.oracle.com/otndocs/jcp/persistence-2_2-mrel-eval-spec/index.html 2017.07.17. 2024.05.13. Oracle Hibernate는 JPA 명세의 구현체입니다. ↩︎\n쉬운 이해를 위해 별도의 예시를 만들기보다 본문 링크에 있는 예시를 최대한 그대로 시용하겠습니다. ↩︎\nSpring Data JPA의 Repository에서 save() 메서드에 해당합니다. ↩︎\nJPA 공식문서에서는 Merge에 대해 다음과 같이 설명하고 있습니다.\nThe merge operation allows for the propagation of state from detached entities onto persistent entities managed by the entity manager. 병합(merge) 작업은 분리(detached)된 엔티티에서의 상태를 엔티티 매니저(entity manager)가 관리하는 영속 엔티티로 전파할 수 있도록 합니다.\n즉, 위 예시에서는 영속 상태의 엔티티를 영속성 컨텍스트에 불러오는 과정에서 Merge 옵션이 있으면 부모와 자식을 한번에 가져오는 것으로 이해할 수 있습니다. ↩︎ JPA 공식문서에서는 다음과 같은 상황에서 분리가 발생한다고 설명하고 있습니다.\n트랜잭션 스코프(persistence context)의 영속성 컨텍스트를 사용하는 경우, 트랜잭션 커밋 시 트랜잭션 롤백 시 엔티티를 영속성 컨텍스트에서 분리(detach)하는 경우 영속성 컨텍스트를 비우는 경우 엔티티 매니저를 닫는 경우 엔티티를 직렬화하거나 엔티티를 값으로 전달할 때(예: 다른 애플리케이션 계층으로, 원격 인터페이스를 통해 등) ↩︎ Lock은 트랜잭션 발생 시 데이터 경합(충돌)이 발생할 것을 예방하기 위해, 조회 시 다른 트랜잭션을 통해 DB가 변경되지 않도록 접근을 통제하는 것을 말합니다. ↩︎\n이렇게 동작시키기 위해서는 jakarta.persistence.lock.scope = PessimisticLockScope.EXTENDED 값을 사용해야 합니다. ↩︎\nHibernate의 Session은 JPA의 영속성 컨텍스트를 구현한 개념입니다. 위 예제에서는 EntityManager의 unwrap() 메서드를 사용하여 Session을 획득한 후, lock() 메서드를 통해 잠금을 설정하고 있습니다. 이 때, CascadeType.LOCK 옵션을 통해 영속성 컨택스트에서 분리(detach)된 부모와 자식 엔티티를 한번에 가져오게 됩니다. ↩︎\nSession에서 영속성 컨텍스트와 실제 Database를 동일하게 맞추는 메서드입니다. 작업 과정에서 DB가 변경되거나 트리거가 실행되어 엔티티와 DB가 다를 때 새로고침을 하여 일치화하는 메서드입니다. ↩︎\nSession에 있는 엔티티를 다른 데이터소스의 데이터와 일치화하는 메서드입니다. ↩︎\n섹션 3.2.3은 cascade=REMOVE에 대한 설명입니다. ↩︎\n","wordCount":"1288","inLanguage":"ko","datePublished":"2024-05-13T21:01:16+09:00","dateModified":"2024-05-13T21:01:16+09:00","author":{"@type":"Person","name":"Leaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leaf-nam.github.io/tips/240513/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"https://leaf-nam.github.io/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/tips/>작고 소중한 미세팁들</a></div><h1 class="post-title entry-hint-parent">JPA Cascade vs Orphan Removal</h1><div class=post-description>Cascade의 개념 차이에 대해 정리합니다.</div><div class=post-meta><span title='2024-05-13 21:01:16 +0900 KST'>2024. 5. 13.</span>&nbsp;·&nbsp;7 분&nbsp;·&nbsp;1288 단어&nbsp;·&nbsp;Leaf&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content/ rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#개요>개요</a></li><li><a href=#jpahibernate-cascade>JPA(Hibernate) Cascade</a><ul><li><a href=#1-all>1. ALL</a></li><li><a href=#2-persist3>2. PERSIST</a></li><li><a href=#3-merge4>3. MERGE</a></li><li><a href=#4-remove>4. REMOVE</a></li><li><a href=#5-detach5>5. DETACH</a></li><li><a href=#6-hibernate-추가-명세>6. Hibernate 추가 명세</a></li></ul></li><li><a href=#orphan-removal>Orphan Removal</a></li><li><a href=#결론>결론</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p>프로젝트를 하던 중, 엔티티 연관관계에서 cascade를 잘못 사용하여 잘못된 엔티티가 삭제되었고, 테스트가 실패하는 상황이 발생했습니다.</p><p>동일한 실수를 반복하지 않도록, 이번 기회에 JPA Cascade 개념과 Orphan Removal과는 어떠한 차이가 있는지 확인해보겠습니다.</p><h2 id=jpahibernate-cascade>JPA(Hibernate) Cascade<a hidden class=anchor aria-hidden=true href=#jpahibernate-cascade>#</a></h2><p>먼저 <a href=https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html#gjjnj>Java EE 6의 가이드</a>에는 다음과 같이 명시되어 있습니다.</p><figure><img loading=lazy src=cascade_jpa.png alt="Java EE6 가이드의 CASCADE 설명"><figcaption><p>Java EE6 가이드의 CASCADE 설명</p></figcaption></figure><p>설명을 읽어보면 Cascade는 영속성 컨텍스트(Persistence Context)에 부모(Cascade옵션을 작성하는 엔티티)가 특정 작업을 수행할 때, 연관된 엔티티(이후 자식이라고 하겠습니다)도 같은 작업을
수행해야 함을 명시하고 있습니다.</p><p>자세한 내용은 <a href=https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html#pc-cascade>Hibernate의 공식문서</a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>
를 살펴보면 더욱 이해하기 좋은 것 같습니다.</p><p>위 문서의 본문 예시를 참조하면 각 옵션의 주요 기능을 알 수 있습니다.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><h3 id=1-all>1. ALL<a hidden class=anchor aria-hidden=true href=#1-all>#</a></h3><ul><li>아래 모든 기능들을 포함하는 속성입니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Entity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Person</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Cascade가 All로 설정되어 모든 옵션이 적용되어 있습니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@OneToMany</span><span class=p>(</span><span class=n>mappedBy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;owner&#34;</span><span class=p>,</span><span class=w> </span><span class=n>cascade</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CascadeType</span><span class=p>.</span><span class=na>ALL</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Phone</span><span class=o>&gt;</span><span class=w> </span><span class=n>phones</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Getter, Setter 생략</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addPhone</span><span class=p>(</span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>phones</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>phone</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>phone</span><span class=p>.</span><span class=na>setOwner</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Entity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Phone</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Column</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;`number`&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>number</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ManyToOne</span><span class=p>(</span><span class=n>fetch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>FetchType</span><span class=p>.</span><span class=na>LAZY</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>owner</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Getter, Setter 생략</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=2-persist3>2. PERSIST<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup><a hidden class=anchor aria-hidden=true href=#2-persist3>#</a></h3><ul><li>DB에 저장될 때 자식을 함께 저장합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : Person과 phone 엔티티 생성 및 등록</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Person</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;John Doe&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Phone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>phone</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>phone</span><span class=p>.</span><span class=na>setNumber</span><span class=p>(</span><span class=s>&#34;123-456-7890&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>addPhone</span><span class=p>(</span><span class=n>phone</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : person 저장</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>person</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 다음과 같이 2개의 Insert 쿼리가 나가면서 연관된 자식을 함께 저장합니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>INSERT</span><span class=w> </span><span class=n>INTO</span><span class=w> </span><span class=nf>Person</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=n>VALUES</span><span class=p>(</span><span class=w> </span><span class=err>&#39;</span><span class=n>John</span><span class=w> </span><span class=n>Doe</span><span class=err>&#39;</span><span class=p>,</span><span class=n>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>INSERT</span><span class=w> </span><span class=n>INTO</span><span class=w> </span><span class=nf>Phone</span><span class=p>(</span><span class=w> </span><span class=err>`</span><span class=n>number</span><span class=err>`</span><span class=p>,</span><span class=w> </span><span class=n>person_id</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=n>VALUES</span><span class=p>(</span><span class=w> </span><span class=err>&#39;</span><span class=n>123</span><span class=o>-</span><span class=n>456</span><span class=o>-</span><span class=n>7890</span><span class=err>&#39;</span><span class=p>,</span><span class=n>1</span><span class=p>,</span><span class=n>1</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h3 id=3-merge4>3. MERGE<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup><a hidden class=anchor aria-hidden=true href=#3-merge4>#</a></h3><ul><li>부모의 상태를 병합할 때, 자동으로 자식의 상태를 함께 확인해서 병합합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : DB에서 엔티티 조회, 변경사항 생성 후 영속성 컨텍스트를 clear() -&gt; 엔티티 분리</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entityManager</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Phone</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>phone</span><span class=p>.</span><span class=na>getOwner</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;John Doe Jr.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>phone</span><span class=p>.</span><span class=na>setNumber</span><span class=p>(</span><span class=s>&#34;987-654-3210&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>clear</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : person 병합(merge)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>person</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 객체를 채우기 위해 다음과 같이 자동으로 Fetch Join이 나가서 자식 엔티티의 값을 채웁니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>SELECT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p</span><span class=p>.</span><span class=na>id</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>id1_0_1_</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p</span><span class=p>.</span><span class=na>name</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>name2_0_1_</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ph</span><span class=p>.</span><span class=na>owner_id</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>owner_id3_1_3_</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ph</span><span class=p>.</span><span class=na>id</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>id1_1_3_</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ph</span><span class=p>.</span><span class=na>id</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>id1_1_0_</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ph</span><span class=p>.</span><span class=s>&#34;number&#34;</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>number2_1_0_</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ph</span><span class=p>.</span><span class=na>owner_id</span><span class=w> </span><span class=n>as</span><span class=w> </span><span class=n>owner_id3_1_0_</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>FROM</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>LEFT</span><span class=w> </span><span class=n>OUTER</span><span class=w> </span><span class=n>JOIN</span><span class=w> </span><span class=n>Phone</span><span class=w> </span><span class=n>ph</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>on</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=na>id</span><span class=o>=</span><span class=n>ph</span><span class=p>.</span><span class=na>owner_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>WHERE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p</span><span class=p>.</span><span class=na>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span></code></pre></div><h3 id=4-remove>4. REMOVE<a hidden class=anchor aria-hidden=true href=#4-remove>#</a></h3><ul><li>부모가 삭제될 떄 자식을 함께 삭제합니다. 참고로 Hibernate에는 DELETE라는 속성도 있는데 같은 동작이라고 합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : person을 불러오기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entityManager</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Person</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : person 삭제</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>person</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 부모가 삭제되기 전 자식을 먼저 삭제합니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>DELETE</span><span class=w> </span><span class=n>FROM</span><span class=w> </span><span class=n>Phone</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>DELETE</span><span class=w> </span><span class=n>FROM</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span></code></pre></div><h3 id=5-detach5>5. DETACH<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup><a hidden class=anchor aria-hidden=true href=#5-detach5>#</a></h3><ul><li>부모가 분리될 때, 자식도 함께 분리합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : person을 불러오기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entityManager</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Person</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>person</span><span class=p>.</span><span class=na>getPhones</span><span class=p>().</span><span class=na>get</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertTrue</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>person</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertTrue</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>phone</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : 영속성 컨텍스트에서 Person을 분리할 경우,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>detach</span><span class=p>(</span><span class=n>person</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 부모가 컨텍스트에서 분리될 떄, 자식도 함께 분리합니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertFalse</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>person</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertFalse</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>phone</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><h3 id=6-hibernate-추가-명세>6. Hibernate 추가 명세<a hidden class=anchor aria-hidden=true href=#6-hibernate-추가-명세>#</a></h3><ul><li>Hibernate에서는 추가로 LOCK, REFRESH, REPLICATE 세가지 옵션을 더 지원합니다.</li><li>Session에서 사용하는 위 세가지 메서드의 편의를 제공하기 위함입니다.</li></ul><p><strong>CascadeType.LOCK<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></strong></p><ul><li>부모 조회 시 Lock이 될때 자식도 lock에 걸릴 것 같지만, 그렇게 동작하지는 않는다고 합니다.<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup></li><li>Lock 옵션을 적용하여 부모를 영속성 컨텍스트에 다시 불러오면(reattach), 자식도 함께 불러오는 옵션입니다.</li><li>아래 예시에서 session<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>의 Lock() 메서드를 통해 부모를 조회하면 자식 또한 함께 조회되는 것을 볼 수 있습니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : person을 불러오기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entityManager</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Person</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertEquals</span><span class=p>(</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>person</span><span class=p>.</span><span class=na>getPhones</span><span class=p>().</span><span class=na>size</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>person</span><span class=p>.</span><span class=na>getPhones</span><span class=p>().</span><span class=na>get</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertTrue</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>person</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertTrue</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>phone</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : 부모 분리 후 lock메서드를 통해 session을 다시 불러올 경우</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>detach</span><span class=p>(</span><span class=n>person</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertFalse</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>person</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertFalse</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>phone</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>unwrap</span><span class=p>(</span><span class=n>Session</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>.</span><span class=na>lock</span><span class=p>(</span><span class=n>person</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LockOptions</span><span class=p>(</span><span class=n>LockMode</span><span class=p>.</span><span class=na>NONE</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 부모, 자식 한번에 조회</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertTrue</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>person</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertTrue</span><span class=p>(</span><span class=n>entityManager</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>phone</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><p><strong>CascadeType.REFRESH<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup></strong></p><ul><li>부모가 새로고침(Refresh) 될 때, 자식도 함께 새로고침하는 옵션입니다.</li><li>정합성 보장을 위해 DB와 영속성 컨텍스트를 일치화 후 작업해야 할 때 유용할 것 같습니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : person을 불러오기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entityManager</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Person</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>person</span><span class=p>.</span><span class=na>getPhones</span><span class=p>().</span><span class=na>get</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : 엔티티 값 변경 후 새로고침하기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;John Doe Jr.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>phone</span><span class=p>.</span><span class=na>setNumber</span><span class=p>(</span><span class=s>&#34;987-654-3210&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>refresh</span><span class=p>(</span><span class=n>person</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 변경사항이 반영되지 않고, DB에 있는 값이 그대로 적용됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertEquals</span><span class=p>(</span><span class=s>&#34;John Doe&#34;</span><span class=p>,</span><span class=w> </span><span class=n>person</span><span class=p>.</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertEquals</span><span class=p>(</span><span class=s>&#34;123-456-7890&#34;</span><span class=p>,</span><span class=w> </span><span class=n>phone</span><span class=p>.</span><span class=na>getNumber</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></div><p><strong>CascadeType.REPLICATE<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup></strong></p><ul><li>부모가 다른 데이터소스를 수정할 때, 자식도 함께 수정하는 옵션입니다.</li><li>CQRS 분리나 Scale Out등을 위해 여러 데이터소스를 함께 사용한다면 유용할 것 같습니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : person과 phone 생성(저장하지 않은 상태)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Person</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;John Doe Sr.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Phone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>phone</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>phone</span><span class=p>.</span><span class=na>setNumber</span><span class=p>(</span><span class=s>&#34;(01) 123-456-7890&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>addPhone</span><span class=p>(</span><span class=n>phone</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : 다른 데이터소스에 있는 값 덮어쓰기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>unwrap</span><span class=p>(</span><span class=n>Session</span><span class=p>.</span><span class=na>class</span><span class=p>).</span><span class=na>replicate</span><span class=p>(</span><span class=n>person</span><span class=p>,</span><span class=w> </span><span class=n>ReplicationMode</span><span class=p>.</span><span class=na>OVERWRITE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 다음과 같이 자동으로 다른 데이터소스를 수정하는 쿼리가 나갑니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>FROM</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>FROM</span><span class=w> </span><span class=n>Phone</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UPDATE</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>SET</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>&#39;</span><span class=n>John</span><span class=w> </span><span class=n>Doe</span><span class=w> </span><span class=n>Sr</span><span class=p>.</span><span class=err>&#39;</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UPDATE</span><span class=w> </span><span class=n>Phone</span><span class=w> </span><span class=n>SET</span><span class=w> </span><span class=s>&#34;number&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>&#39;</span><span class=p>(</span><span class=n>01</span><span class=p>)</span><span class=w> </span><span class=n>123</span><span class=o>-</span><span class=n>456</span><span class=o>-</span><span class=n>7890</span><span class=err>&#39;</span><span class=p>,</span><span class=w> </span><span class=n>owner_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>지금까지 JPA와 Hibernate의 Cascade 옵션에 대해 알아보았습니다. 결국 영속성 컨텍스트에 부모-자식 엔티티를 한번에 불러오거나 생성, 변경, 삭제하는 옵션이라고 할 수 있겠습니다.</p></blockquote><h2 id=orphan-removal>Orphan Removal<a hidden class=anchor aria-hidden=true href=#orphan-removal>#</a></h2><p>다음은 Orphan Removal 옵션입니다.</p><p>해당 옵션에 대한 설명은 <a href=https://download.oracle.com/otndocs/jcp/persistence-2_2-mrel-eval-spec/index.html>JPA 기본 명세</a> 45p에 잘 나와있습니다.(GPT 3.5 번역)</p><blockquote><p>일대일(OneToOne) 또는 일대다(OneToMany)로 지정된 연관 관계는 orphanRemoval 옵션을 사용할 수 있습니다. orphanRemoval이 적용될 때 다음과 같은 동작이 발생합니다:</p></blockquote><blockquote><p>연관 관계의 대상이 되는 엔터티가 연관 관계에서 제거되면(예: 연관 관계를 null로 설정하거나 연관 관계 컬렉션에서 엔터티를 제거함으로써), 고아가 된 엔터티에 대해 삭제 작업이 적용됩니다. 삭제 작업은 플러시(flush) 작업 시점에 적용됩니다. orphanRemoval 기능은 부모 엔터티에 의해 개인적으로 &ldquo;소유"되는 엔터티를 위해 의도된 것입니다. 이 기능을 사용할 경우, 응용 프로그램은 특정한 제거 순서에 의존해서는 안 되며, 고아가 된 엔터티를 다른 연관 관계에 재할당하거나 해당 엔터티를 지속(persist)하려고 시도해서는 안 됩니다. 고아가 된 엔터티가 분리(detached) 상태이거나, 새로 생성된 상태이거나, 삭제된 상태인 경우, orphanRemoval의 의미는 적용되지 않습니다.</p></blockquote><blockquote><p>관리되는 소스 엔터티에 대해 삭제 작업이 적용되면, 삭제 작업은 섹션 3.2.3<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>의 규칙에 따라 연관 관계의 대상 엔터티에 전파됩니다(따라서 연관 관계에 대해 cascade=REMOVE를 명시할 필요는 없습니다).</p></blockquote><p>즉, 일대일 또는 일대다 연관관계에서 <strong>부모 엔티티의 참조가 사라지면, 영속성 컨텍스트를 flush하는 시점에 자식 엔티티를 삭제</strong>합니다.</p><p>또한, <strong>부모 엔티티를 삭제하면 자동으로 cascade=REMOVE를 적용한 것과 같이 자식을 삭제</strong>하는 효과도 줍니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// given : person을 불러오기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Person</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entityManager</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Person</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Phone</span><span class=w> </span><span class=n>phone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>person</span><span class=p>.</span><span class=na>getPhones</span><span class=p>().</span><span class=na>get</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assertEquals</span><span class=p>(</span><span class=n>phone</span><span class=p>.</span><span class=na>getId</span><span class=p>(),</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// when : person에서 phone 참조값 제거 후 flush</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>person</span><span class=p>.</span><span class=na>getPhones</span><span class=p>().</span><span class=na>set</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>entityManager</span><span class=p>.</span><span class=na>flush</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// then : 참조가 사라진 자식(고아) 엔티티를 삭제합니다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>DELETE</span><span class=w> </span><span class=n>FROM</span><span class=w> </span><span class=n>Phone</span><span class=w> </span><span class=n>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span></code></pre></div><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><ul><li>제가 잘못 이해하고 있던 부분은 CascadeType.REMOVE는 삭제되는게 아니라 영속성 컨텍스트에서 분리될 때 함께 분리된다고 생각한 점이었습니다(이 기능은 CascadeType.DETACH와 헷갈렸던 것 같습니다.).</li><li>사실 Orphan Removal과 CascadeType.REMOVE는 기능적으로는 동일하지만, REMOVE는 삭제(EntityManager.remove())를 명시할때만 발동되는 반면 Orphan Removal은 삭제 뿐 아니라 null이나 참조값 변경 등으로 참조가 없어질 때에도 삭제하는 것이 가장 큰 차이인 것 같습니다.<blockquote><p>두루뭉실하게 알고 있던 지식들이 공식문서를 통해 접하니 좀더 확실하게 알게 된 느낌입니다. 앞으로도 잘 모르겠다 싶으면 공식문서를 참고하는 습관을 들여야겠습니다.</p></blockquote></li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><table><thead><tr><th style=text-align:left>URL</th><th style=text-align:left>게시일자</th><th style=text-align:left>방문일자</th><th style=text-align:left>작성자</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html#gjjnj>https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html#gjjnj</a></td><td style=text-align:left>2013.</td><td style=text-align:left>2024.05.13.</td><td style=text-align:left>Oracle</td></tr><tr><td style=text-align:left><a href=https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html>https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html</a></td><td style=text-align:left>2024.05.03.</td><td style=text-align:left>2024.05.13.</td><td style=text-align:left>Hibernate</td></tr><tr><td style=text-align:left><a href=https://download.oracle.com/otndocs/jcp/persistence-2_2-mrel-eval-spec/index.html>https://download.oracle.com/otndocs/jcp/persistence-2_2-mrel-eval-spec/index.html</a></td><td style=text-align:left>2017.07.17.</td><td style=text-align:left>2024.05.13.</td><td style=text-align:left>Oracle</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Hibernate는 JPA 명세의 구현체입니다.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>쉬운 이해를 위해 별도의 예시를 만들기보다 본문 링크에 있는 예시를 최대한 그대로 시용하겠습니다.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Spring Data JPA의 Repository에서 save() 메서드에 해당합니다.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://download.oracle.com/otndocs/jcp/persistence-2_2-mrel-eval-spec/index.html>JPA 공식문서</a>에서는 Merge에 대해 다음과 같이 설명하고 있습니다.</p><ul><li>The merge operation allows for the propagation of state from detached entities onto persistent entities
managed by the entity manager.<blockquote><p>병합(merge) 작업은 분리(detached)된 엔티티에서의 상태를 엔티티 매니저(entity manager)가 관리하는 영속 엔티티로 전파할 수 있도록 합니다.</p></blockquote></li><li>즉, 위 예시에서는 영속 상태의 엔티티를 영속성 컨텍스트에 불러오는 과정에서 Merge 옵션이 있으면 부모와 자식을 한번에 가져오는 것으로 이해할 수 있습니다.</li></ul>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:5><p><a href=https://download.oracle.com/otndocs/jcp/persistence-2_2-mrel-eval-spec/index.html>JPA 공식문서</a>에서는 다음과 같은 상황에서 분리가 발생한다고 설명하고 있습니다.</p><ol><li>트랜잭션 스코프(persistence context)의 영속성 컨텍스트를 사용하는 경우, 트랜잭션 커밋 시</li><li>트랜잭션 롤백 시</li><li>엔티티를 영속성 컨텍스트에서 분리(detach)하는 경우</li><li>영속성 컨텍스트를 비우는 경우</li><li>엔티티 매니저를 닫는 경우</li><li>엔티티를 직렬화하거나 엔티티를 값으로 전달할 때(예: 다른 애플리케이션 계층으로, 원격 인터페이스를 통해 등)</li></ol>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:6><p>Lock은 트랜잭션 발생 시 데이터 경합(충돌)이 발생할 것을 예방하기 위해, 조회 시 다른 트랜잭션을 통해 DB가 변경되지 않도록 접근을 통제하는 것을 말합니다.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>이렇게 동작시키기 위해서는 jakarta.persistence.lock.scope = PessimisticLockScope.EXTENDED 값을 사용해야 합니다.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>Hibernate의 Session은 JPA의 영속성 컨텍스트를 구현한 개념입니다. 위 예제에서는 EntityManager의 unwrap() 메서드를 사용하여 Session을 획득한 후, lock() 메서드를 통해 잠금을 설정하고 있습니다. 이 때, CascadeType.LOCK 옵션을 통해 영속성 컨택스트에서 분리(detach)된 부모와 자식 엔티티를 한번에 가져오게 됩니다.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>Session에서 영속성 컨텍스트와 실제 Database를 동일하게 맞추는 메서드입니다. 작업 과정에서 DB가 변경되거나 트리거가 실행되어 엔티티와 DB가 다를 때 새로고침을 하여 일치화하는 메서드입니다.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>Session에 있는 엔티티를 <strong>다른 데이터소스의 데이터</strong>와 일치화하는 메서드입니다.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>섹션 3.2.3은 cascade=REMOVE에 대한 설명입니다.&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://leaf-nam.github.io/tags/concept/>Concept</a></li><li><a href=https://leaf-nam.github.io/tags/jpa/>JPA</a></li><li><a href=https://leaf-nam.github.io/tags/hibernate/>Hibernate</a></li></ul><nav class=paginav><a class=prev href=https://leaf-nam.github.io/cote/bj_16927/><span class=title>« 이전 페이지</span><br><span>[Java]백준 16927 배열 돌리기 2</span>
</a><a class=next href=https://leaf-nam.github.io/tips/240507/><span class=title>다음 페이지 »</span><br><span>MockMvc Object mapper nested class utf-8 인코딩 오류 해결하기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on x" href="https://x.com/intent/tweet/?text=JPA%20Cascade%20vs%20Orphan%20Removal&amp;url=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f&amp;hashtags=concept%2cJPA%2cHibernate"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f&amp;title=JPA%20Cascade%20vs%20Orphan%20Removal&amp;summary=JPA%20Cascade%20vs%20Orphan%20Removal&amp;source=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f&title=JPA%20Cascade%20vs%20Orphan%20Removal"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on whatsapp" href="https://api.whatsapp.com/send?text=JPA%20Cascade%20vs%20Orphan%20Removal%20-%20https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on telegram" href="https://telegram.me/share/url?text=JPA%20Cascade%20vs%20Orphan%20Removal&amp;url=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JPA Cascade vs Orphan Removal on ycombinator" href="https://news.ycombinator.com/submitlink?t=JPA%20Cascade%20vs%20Orphan%20Removal&u=https%3a%2f%2fleaf-nam.github.io%2ftips%2f240513%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>