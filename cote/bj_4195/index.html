<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Java]백준 4195 친구 네트워크 | 봄을 기다리는 낙엽</title>
<meta name=keywords content="codingtest,backjoon,union-find"><meta name=description content="백준 4195 친구 네트워크 문제에 대한 해설입니다."><meta name=author content="Leaf"><link rel=canonical href=https://leaf-nam.github.io/cote/bj_4195/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/cote/bj_4195/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/cote/bj_4195/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="[Java]백준 4195 친구 네트워크"><meta property="og:description" content="백준 4195 친구 네트워크 문제에 대한 해설입니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="cote"><meta property="article:published_time" content="2024-06-03T06:59:21+09:00"><meta property="article:modified_time" content="2024-06-03T06:59:21+09:00"><meta property="article:tag" content="Codingtest"><meta property="article:tag" content="Backjoon"><meta property="article:tag" content="Union-Find"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Java]백준 4195 친구 네트워크"><meta name=twitter:description content="백준 4195 친구 네트워크 문제에 대한 해설입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"코딩테스트","item":"https://leaf-nam.github.io/cote/"},{"@type":"ListItem","position":2,"name":"[Java]백준 4195 친구 네트워크","item":"https://leaf-nam.github.io/cote/bj_4195/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Java]백준 4195 친구 네트워크","name":"[Java]백준 4195 친구 네트워크","description":"백준 4195 친구 네트워크 문제에 대한 해설입니다.","keywords":["codingtest","backjoon","union-find"],"articleBody":"출처 https://www.acmicpc.net/problem/4195 접근 처음에는 문제가 잘 이해되지 않았습니다.1 몇 번 읽어보니, 두 정점이 주어지면 두 정점을 연결하고 같은 그래프 내에 있는 모든 친구 개수를 출력하는 문제임을 알았습니다. ①, ②을 통해 연결된 네트워크는 각각 친구가 2명이며, ③을 통해 두 네트워크가 연결되면 총 친구는 4명입니다.\n친구관계가 연결되어 같은 그래프에 포함되는 과정이 Union-Find 알고리즘과 동일하기 때문에, 이를 활용하여 해결할 수 있습니다. 유니온 파인드(Union Find) Union과 Find 메서드를 통해 서로소 집합2을 연결하는 알고리즘입니다. 각 집합의 단위는 Root로부터 하위 원소들로 구성되며, 모든 원소들은 동일한 Root를 바라보는 특징이 있습니다. Union과 Find를 간략히 그림으로 나타내면 다음과 같습니다. 노란색 : 부모 / 빨간색 : 유니온(Union) 메서드 / 파란색 : 파인드(find) 메서드\nRoot는 본인을 바라보는 노드이며, 최초 네트워크가 구성될 때 본인을 바라보도록 만듭니다. Union union 연산을 수행하면, 서로 교집합이 없는 두 네트워크의 Root를 한쪽을 바라보도록 연결합니다. 이 때, 한쪽 네트워크의 부모를 다른 네트워크의 부모를 바라보도록 변경해주면 되므로 연결 과정은 O(1)로 연산이 가능합니다. Find find 연산을 수행하면, 부모가 본인인 노드(Root)가 나올때까지 탐색을 수행합니다. 만약 네트워크 끝에서부터 탐색한다면(위 그림에서 3, 5번 노드), 최대 O(N)의 시간복잡도가 필요합니다. 이를 줄이기 위해 Find과정에서 만나는 부모들을 모두 부모를 바라보도록 변경하는 작업을 수행하면, 처음 탐색속도는 동일하게 O(N)이지만 이후 탐색속도는 O(1)이 되도록 개선할 수 있습니다.3 풀이 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.StringTokenizer; /* * [조건] * 시간제한 : 3초 / 메모리제한 : 256MB * F \u003c= 100,000 / name.length() \u003c= 20 * [풀이] * Union find 알고리즘을 통해 공통 친구 네트워크의 개수를 구한다. * 친구 집합의 root를 find를 통해 찾는다. * root가 아직 정해지지 않았다면, 공통 집합에 가입시킨다. * 두 친구관계가 만나면 Union을 통해 공통 집합에 가입시키고, 공통 집합의 크기를 더한다. */ public class bj_4195_친구_네트워크 { static int groupId = 0; static HashMap\u003cString, String\u003e friendship; // 친구관계(부모)를 가리키는 해시맵 static HashMap\u003cString, Integer\u003e rootCount; // 네트워크 크기를 루트와 매핑하는 해시맵 public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for (int i = 0; i \u003c T; i++) { int F = Integer.parseInt(br.readLine()); friendship = new HashMap\u003c\u003e(); rootCount = new HashMap\u003c\u003e(); for (int j = 0; j \u003c F; j++) { StringTokenizer st = new StringTokenizer(br.readLine()); String f1 = st.nextToken(); String f2 = st.nextToken(); System.out.println(getFriends(f1, f2)); } } } /* * 집합(친구관계)을 생성하는 메서드 */ static void makeSet(String s) { friendship.put(s, s); // 최초 친구 : 1명 rootCount.put(s, 1); } /* * 각 네트워크의 루트를 찾아(Find) 두 관계를 합치는 메서드 * 왼쪽값의 root에 오른쪽을 편입시킴 */ static int union(String s1, String s2) { String root1 = find(s1); String root2 = find(s2); // 이미 친구일 경우 예외처리 if (root1.equals(root2)) return rootCount.get(root1); // 네트워크 편입 friendship.put(root2, root1); // 편입 시 두 네트워크의 합으로 루트 해시맵의 값을 변경, 네트워크의 합 return int value = rootCount.get(root1) + rootCount.get(root2); rootCount.put(root1, value); return value; } /* * 부모를 찾는 메서드 * HashMap의 값이 본인이 아니면 본인이 나올때까지 재귀호출하여 path compression * HashMap의 값 == 본인 이면 root */ static String find(String me) { // Recursive Path Compression(재귀적으로 부모값을 루트로 변경시켜 이후 탐색속도 높임) if (!me.equals(friendship.get(me))) friendship.put(me, find(friendship.get(me))); return friendship.get(me); } /* * 두 네트워크를 합치고 공통의 친구 개수를 찾는 메서드 */ static int getFriends(String f1, String f2) { if (!friendship.containsKey(f1)) makeSet(f1); if (!friendship.containsKey(f2)) makeSet(f2); return union(f1, f2); } } 결과 리뷰 오랜만에 유니온 파인드 알고리즘을 만나서 복습해볼 수 있었습니다. 중간에 같은 네트워크에 이미 소속된 두 친구가 만났을 경우를 예외처리하지 않아서 조금 헤맸습니다. 확실히 구현문제는 예외 상황들을 미리 그려놓고 문제 풀이에 들어가야 빠르게 처리할 수 있는 것 같습니다. References URL 게시일자 방문일자 작성자 개인적으로 영어 원문으로 변경하니 더 이해가 쉬웠던 것 같습니다. ↩︎\n서로 중복(교집합)이 없는 집합을 말합니다. 애초에 교집합이 있다면 같은 네트워크 안에 포함되어 있기 때문에 유니온 연산이 불가능합니다. ↩︎\n위 과정을 경로 압축(Path Compression)이라고 부릅니다. 이번 문제에서 경로압축을 하지않으면 O(N)의 탐색을 N(100,000)회 수행하므로 O(N^2) ≒ 2^40 으로 시간초과가 발생합니다. ↩︎\n","wordCount":"612","inLanguage":"ko","datePublished":"2024-06-03T06:59:21+09:00","dateModified":"2024-06-03T06:59:21+09:00","author":{"@type":"Person","name":"Leaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leaf-nam.github.io/cote/bj_4195/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"https://leaf-nam.github.io/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/cote/>코딩테스트</a></div><h1 class="post-title entry-hint-parent">[Java]백준 4195 친구 네트워크</h1><div class=post-description>백준 4195 친구 네트워크 문제에 대한 해설입니다.</div><div class=post-meta><span title='2024-06-03 06:59:21 +0900 KST'>2024. 6. 3.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;612 단어&nbsp;·&nbsp;Leaf&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content/ rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#출처>출처</a></li><li><a href=#접근>접근</a><ul><li><a href=#유니온-파인드union-find>유니온 파인드(Union Find)</a></li></ul></li><li><a href=#풀이>풀이</a></li><li><a href=#결과>결과</a></li><li><a href=#리뷰>리뷰</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=출처>출처<a hidden class=anchor aria-hidden=true href=#출처>#</a></h2><ul><li><a href=https://www.acmicpc.net/problem/4195>https://www.acmicpc.net/problem/4195</a></li></ul><h2 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h2><ul><li>처음에는 문제가 잘 이해되지 않았습니다.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>몇 번 읽어보니, 두 정점이 주어지면 두 정점을 연결하고 같은 그래프 내에 있는 모든 친구 개수를 출력하는 문제임을 알았습니다.<figure><img loading=lazy src=solve2.jpeg alt="①, ②을 통해 연결된 네트워크는 각각 친구가 2명이며, ③을 통해 두 네트워크가 연결되면 총 친구는 4명입니다."><figcaption><p>①, ②을 통해 연결된 네트워크는 각각 친구가 2명이며, ③을 통해 두 네트워크가 연결되면 총 친구는 4명입니다.</p></figcaption></figure></li><li>친구관계가 연결되어 같은 그래프에 포함되는 과정이 Union-Find 알고리즘과 동일하기 때문에, 이를 활용하여 해결할 수 있습니다.</li></ul><h3 id=유니온-파인드union-find>유니온 파인드(Union Find)<a hidden class=anchor aria-hidden=true href=#유니온-파인드union-find>#</a></h3><ul><li>Union과 Find 메서드를 통해 서로소 집합<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>을 연결하는 알고리즘입니다.</li><li>각 집합의 단위는 Root로부터 하위 원소들로 구성되며, 모든 원소들은 동일한 Root를 바라보는 특징이 있습니다.</li><li>Union과 Find를 간략히 그림으로 나타내면 다음과 같습니다.<figure><img loading=lazy src=solve3.jpeg alt="노란색 : 부모 / 빨간색 : 유니온(Union) 메서드 / 파란색 : 파인드(find) 메서드"><figcaption><p>노란색 : 부모 / 빨간색 : 유니온(Union) 메서드 / 파란색 : 파인드(find) 메서드</p></figcaption></figure></li></ul><ol><li>Root는 본인을 바라보는 노드이며, 최초 네트워크가 구성될 때 본인을 바라보도록 만듭니다.</li></ol><h4 id=union>Union<a hidden class=anchor aria-hidden=true href=#union>#</a></h4><ul><li>union 연산을 수행하면, 서로 교집합이 없는 두 네트워크의 Root를 한쪽을 바라보도록 연결합니다.</li><li>이 때, 한쪽 네트워크의 부모를 다른 네트워크의 부모를 바라보도록 변경해주면 되므로 연결 과정은 O(1)로 연산이 가능합니다.</li></ul><h4 id=find>Find<a hidden class=anchor aria-hidden=true href=#find>#</a></h4><ul><li>find 연산을 수행하면, 부모가 본인인 노드(Root)가 나올때까지 탐색을 수행합니다.</li><li>만약 네트워크 끝에서부터 탐색한다면(위 그림에서 3, 5번 노드), 최대 O(N)의 시간복잡도가 필요합니다.</li><li>이를 줄이기 위해 Find과정에서 만나는 부모들을 모두 부모를 바라보도록 변경하는 작업을 수행하면, 처음 탐색속도는 동일하게 O(N)이지만 이후 탐색속도는 O(1)이 되도록 개선할 수 있습니다.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ul><h2 id=풀이>풀이<a hidden class=anchor aria-hidden=true href=#풀이>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.io.BufferedReader</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.io.IOException</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.io.InputStreamReader</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.util.HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.util.LinkedList</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.util.List</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.util.StringTokenizer</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * [조건]
</span></span></span><span class=line><span class=cl><span class=cm> * 시간제한 : 3초 / 메모리제한 : 256MB
</span></span></span><span class=line><span class=cl><span class=cm> * F &lt;= 100,000 / name.length() &lt;= 20
</span></span></span><span class=line><span class=cl><span class=cm> * [풀이]
</span></span></span><span class=line><span class=cl><span class=cm> * Union find 알고리즘을 통해 공통 친구 네트워크의 개수를 구한다.
</span></span></span><span class=line><span class=cl><span class=cm> * 친구 집합의 root를 find를 통해 찾는다.
</span></span></span><span class=line><span class=cl><span class=cm> * root가 아직 정해지지 않았다면, 공통 집합에 가입시킨다.
</span></span></span><span class=line><span class=cl><span class=cm> * 두 친구관계가 만나면 Union을 통해 공통 집합에 가입시키고, 공통 집합의 크기를 더한다.
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>bj_4195_친구_네트워크</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>groupId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>friendship</span><span class=p>;</span><span class=w> </span><span class=c1>// 친구관계(부모)를 가리키는 해시맵</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>rootCount</span><span class=p>;</span><span class=w> </span><span class=c1>// 네트워크 크기를 루트와 매핑하는 해시맵</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>BufferedReader</span><span class=w> </span><span class=n>br</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BufferedReader</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InputStreamReader</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>in</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>parseInt</span><span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=na>readLine</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>F</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>parseInt</span><span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=na>readLine</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>friendship</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>rootCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>F</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>StringTokenizer</span><span class=w> </span><span class=n>st</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringTokenizer</span><span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=na>readLine</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>String</span><span class=w> </span><span class=n>f1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>st</span><span class=p>.</span><span class=na>nextToken</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>String</span><span class=w> </span><span class=n>f2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>st</span><span class=p>.</span><span class=na>nextToken</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>getFriends</span><span class=p>(</span><span class=n>f1</span><span class=p>,</span><span class=w> </span><span class=n>f2</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 집합(친구관계)을 생성하는 메서드
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>makeSet</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>friendship</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 최초 친구 : 1명</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rootCount</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 각 네트워크의 루트를 찾아(Find) 두 관계를 합치는 메서드
</span></span></span><span class=line><span class=cl><span class=cm>     * 왼쪽값의 root에 오른쪽을 편입시킴
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>union</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>s2</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>root1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>root2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>s2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 이미 친구일 경우 예외처리</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>root1</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>root2</span><span class=p>))</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>rootCount</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>root1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 네트워크 편입</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>friendship</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>root2</span><span class=p>,</span><span class=w> </span><span class=n>root1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 편입 시 두 네트워크의 합으로 루트 해시맵의 값을 변경, 네트워크의 합 return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rootCount</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>root1</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rootCount</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>root2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rootCount</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>root1</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 부모를 찾는 메서드
</span></span></span><span class=line><span class=cl><span class=cm>     * HashMap의 값이 본인이 아니면 본인이 나올때까지 재귀호출하여 path compression
</span></span></span><span class=line><span class=cl><span class=cm>     * HashMap의 값 == 본인 이면 root
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>find</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>me</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=c1>// Recursive Path Compression(재귀적으로 부모값을 루트로 변경시켜 이후 탐색속도 높임)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>me</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>friendship</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>me</span><span class=p>)))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>friendship</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>me</span><span class=p>,</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>friendship</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>me</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>friendship</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>me</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 두 네트워크를 합치고 공통의 친구 개수를 찾는 메서드
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getFriends</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>f1</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>f2</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>friendship</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>f1</span><span class=p>))</span><span class=w> </span><span class=n>makeSet</span><span class=p>(</span><span class=n>f1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>friendship</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>f2</span><span class=p>))</span><span class=w> </span><span class=n>makeSet</span><span class=p>(</span><span class=n>f2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>union</span><span class=p>(</span><span class=n>f1</span><span class=p>,</span><span class=w> </span><span class=n>f2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=결과>결과<a hidden class=anchor aria-hidden=true href=#결과>#</a></h2><p><img alt=result loading=lazy src=/cote/bj_4195/solve4.png></p><h2 id=리뷰>리뷰<a hidden class=anchor aria-hidden=true href=#리뷰>#</a></h2><ul><li>오랜만에 유니온 파인드 알고리즘을 만나서 복습해볼 수 있었습니다.</li><li>중간에 같은 네트워크에 이미 소속된 두 친구가 만났을 경우를 예외처리하지 않아서 조금 헤맸습니다.</li><li>확실히 구현문제는 예외 상황들을 미리 그려놓고 문제 풀이에 들어가야 빠르게 처리할 수 있는 것 같습니다.</li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><table><thead><tr><th style=text-align:left>URL</th><th style=text-align:left>게시일자</th><th style=text-align:left>방문일자</th><th style=text-align:left>작성자</th></tr></thead><tbody></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>개인적으로 영어 원문으로 변경하니 더 이해가 쉬웠던 것 같습니다.
<img alt=원문 loading=lazy src=/cote/bj_4195/solve1.png>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>서로 중복(교집합)이 없는 집합을 말합니다. 애초에 교집합이 있다면 같은 네트워크 안에 포함되어 있기 때문에 유니온 연산이 불가능합니다.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>위 과정을 경로 압축(Path Compression)이라고 부릅니다. 이번 문제에서 경로압축을 하지않으면 O(N)의 탐색을 N(100,000)회 수행하므로 O(N^2) ≒ 2^40 으로 시간초과가 발생합니다.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://leaf-nam.github.io/tags/codingtest/>Codingtest</a></li><li><a href=https://leaf-nam.github.io/tags/backjoon/>Backjoon</a></li><li><a href=https://leaf-nam.github.io/tags/union-find/>Union-Find</a></li></ul><nav class=paginav><a class=prev href=https://leaf-nam.github.io/cote/bj_1806/><span class=title>« 이전 페이지</span><br><span>[Java]백준 1806 부분합</span>
</a><a class=next href=https://leaf-nam.github.io/cote/bj_12904/><span class=title>다음 페이지 »</span><br><span>[Java]백준 12904 A와 B</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on x" href="https://x.com/intent/tweet/?text=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac&amp;url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f&amp;hashtags=codingtest%2cbackjoon%2cunion-find"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f&amp;title=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac&amp;summary=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac&amp;source=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f&title=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on whatsapp" href="https://api.whatsapp.com/send?text=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20-%20https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on telegram" href="https://telegram.me/share/url?text=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac&amp;url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]백준 4195 친구 네트워크 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bJava%5d%eb%b0%b1%ec%a4%80%204195%20%ec%b9%9c%ea%b5%ac%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac&u=https%3a%2f%2fleaf-nam.github.io%2fcote%2fbj_4195%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>