<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) | 봄을 기다리는 낙엽</title>
<meta name=keywords content="codingtest,programmers,BFS"><meta name=description content="Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 문제에 대한 해설입니다."><meta name=author content="Leaf"><link rel=canonical href=https://leaf-nam.github.io/cote/programmers_118669/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/cote/programmers_118669/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/cote/programmers_118669/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)"><meta property="og:description" content="Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 문제에 대한 해설입니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="cote"><meta property="article:published_time" content="2025-01-22T10:50:48+09:00"><meta property="article:modified_time" content="2025-01-22T10:50:48+09:00"><meta property="article:tag" content="Codingtest"><meta property="article:tag" content="Programmers"><meta property="article:tag" content="BFS"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)"><meta name=twitter:description content="Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 문제에 대한 해설입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"코딩테스트","item":"https://leaf-nam.github.io/cote/"},{"@type":"ListItem","position":2,"name":"[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)","item":"https://leaf-nam.github.io/cote/programmers_118669/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)","name":"[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)","description":"Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 문제에 대한 해설입니다.","keywords":["codingtest","programmers","BFS"],"articleBody":"출처 Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 접근 문제 분석 산의 봉우리까지 이동하는 과정을 시뮬레이션 하는 문제입니다. Intensity는 이동 과정에서 가장 긴시간을 뜻합니다. 문제에서는 정상에 도착한 후, 다시 출입구로 돌아와야 한다고 했지만 올라갔던 길을 그대로 내려올 수 있기 때문에, 정상까지만 경로를 추적하면 됩니다. 따라서 각 출발지(Gate)에서 도착지(Summit)까지의 Intensity가 최소가 되도록 완전탐색을 수행해야 합니다. 조건 분석 문제에서 주어진 정점(Vertex)은 n = 50,000 이고 간선(Edge)은 paths = 200,000입니다. 탐색의 시작점이 최대 n이기 때문에, 이미 방문한 정점을 필요시에만 재방문하도록 최적화하면 시간복잡도 내 문제를 해결할 수 있습니다. 전체 간선을 1회만 탐색할 경우 시간복잡도는 O(N) = E + V = 250,000가 됩니다.1\n이 때, 정점의 개수에 비해 간선이 적으므로, 인접 리스트를 활용하는 것이 효과적입니다.2 간선의 개수가 적은 그래프에서 행렬(n x n matrix)을 사용하게 되면, 불필요한 탐색 및 메모리 초과가 발생할 수 있습니다.\nBFS 한 정점에서 다른 정점으로 이동 시, 깊이를 따라 이동하면(DFS) 불필요한 탐색이 발생하기 때문에 시간초과가 발생할 수 있습니다.\n아래와 같은 깊은 그래프가 있다고 가정하겠습니다. DFS는 산꼭대기에 도착할때까지 깊이가 계속 깊어지므로, 다음과 같이 깊은 그래프에서는 모든 경로를 탐색하면서 시간복잡도가 계속 증가하게 됩니다. 그러나 BFS에서는 최단 경로로만 이동하기 때문에 불필요한 탐색을 최적화할 수 있습니다. 방문처리 최적화 단순히 방문여부로 방문체크를 한다면, 이후에 더 작은 Intensity로 방문하는 경우를 탐색할 수 없기 때문에, 방문처리 배열은 DP 형태로 Intensity 최솟값을 저장해야 합니다.\n문제에서 주어진 시작점이 여러개이기 때문에, 새로운 시작점에서 서로 다른 BFS를 수행하게 됩니다.\n그러나, 이전 등산코스에서 방문했던 지점이라면, 새로운 BFS에서 다시 방문할 필요가 없기 때문에 이를 최적화할 수 있습니다.\n위와 같이 1번 시작점에서 Intensity = 3으로 방문했던 지점이라면, 3번 시작점에서는 어떻게 해도 Intensity를 줄일 수 없기 때문에 해당 정점은 더이상 방문할 필요가 없습니다. 더 나아가서, 탐색 과정에서 해당 정점을 이미 더 작은 가중치로 다시 방문할 필요가 없기 때문에 최적화가 가능합니다.\n최소 가중치만 방문하는 점에서 다익스트라 알고리즘이 됩니다.\n도착지 최적화 도착지를 Set에 삽입하면, 해당 지점이 도착지인지 O(1)로 판단할 수 있기 때문에 도착여부를 빠르게 파악할 수 있습니다. 이 때, 문제에서 산봉우리 번호가 더 낮은 등산코스를 선택해야 하기 때문에, 더 빠른 도착지점이 앞으로 올 수 있도록 TreeSet으로 구현체를 선택합니다. TreeSet은 내부 원소를 정렬된 형태로 유지합니다.\n풀이 import java.util.*; class Solution { // 정답 초기화 int[] answer = {0, 10_000_001}; public int[] solution(int n, int[][] paths, int[] gates, int[] summits) { // 인접리스트 정의 및 생성 List\u003cint[]\u003e[] adjList = new List[n + 1]; for (int i = 0; i \u003c paths.length; i++) { int start = paths[i][0], end = paths[i][1], time = paths[i][2]; if (adjList[start] == null) adjList[start] = new ArrayList\u003c\u003e(); if (adjList[end] == null) adjList[end] = new ArrayList\u003c\u003e(); adjList[start].add(new int[] {end, time}); adjList[end].add(new int[] {start, time}); } // DP 형태의 방문배열 int[] isVisited = new int[n + 1]; Arrays.fill(isVisited, 10_000_001); // 도착지 Set Set\u003cInteger\u003e summitSet = new TreeSet\u003c\u003e(); for (int summit : summits) summitSet.add(summit); // 각 시작지점에서 다익스트라 수행 for (int start : gates){ dijkstra(n, start, adjList, isVisited, summitSet); } return answer; } void dijkstra(int n, int start, List\u003cint[]\u003e[] adjList, int[] isVisited, Set\u003cInteger\u003e summitSet) { // Dijkstra를 위한 PriorityQueue PriorityQueue\u003cint[]\u003e q = new PriorityQueue\u003c\u003e((o1, o2) -\u003e Integer.compare(o1[1], o2[1])); isVisited[start] = 0; q.offer(new int[] {start, 0}); while (!q.isEmpty()) { int[] now = q.poll(); // 탐색 과정에서 더 작은 가중치가 발생한 경우 탐색 종료 if (now[1] \u003e isVisited[now[0]]) continue; // 도착지점일 경우 탐색 종료 if (summitSet.contains(now[0])) continue; for (int[] adjs : adjList[now[0]]) { // Intensity : 현재 경로에서 가장 긴 시간 int intensity = Math.max(adjs[1], now[1]); // 방문체크 : Intensity가 더 작을때만 재방문 if (intensity \u003e= isVisited[adjs[0]]) continue; isVisited[adjs[0]] = intensity; // 새로운 지점에서 다시 BFS q.offer(new int[] {adjs[0], intensity}); } } // 산봉우리의 최솟값 찾기 int minSummit = 0, minIntensity = 10_000_001; // TreeSet이므로 번호가 낮은 산봉우리부터 확인 for (int summit : summitSet) { // 번호가 큰 산봉우리는 Intensity 최솟값이 작을때만 갱신 if (isVisited[summit] \u003c minIntensity) { minIntensity = isVisited[summit]; minSummit = summit; } } // 정답 최신화 if ((answer[1] \u003e minIntensity) || // Intensity가 같으면 번호 확인 (answer[1] == minIntensity \u0026\u0026 answer[0] \u003e minSummit)) { answer = new int[] {minSummit, minIntensity}; } } } 결과 소요 시간 : 1시간 30분 리뷰 문제를 정확히 이해하지 않고 구현하려다 보니 구현이 오래 걸렸습니다. 코스에서 가중치가 가장 작은 값만 확인하면 되므로 일반적인 Dijkstra와는 다른 로직임을 나중에야 알게 되었습니다. 문제를 정확히 이해하고 구현하는 습관을 길러야겠습니다.\nReferences URL 게시일자 방문일자 작성자 희소 그래프 2023.04.01. 2025.01.22. Wikipedia 물론 문제에서 각 정점을 1번씩만 방문하지는 않겠지만, 이미 방문한 정점을 특정 조건에서만 방문하도록 최적화하면 유사한 시간복잡도 내에서 탐색이 가능합니다.\n다익스트라를 사용하면 시작점 1개의 탐색횟수는 O(N) = ElogV = paths * log(n) = 3,122,000가 되지만, 다음 시작점의 탐색에서는 방문 배열을 통해 필요한 정점만 재방문하므로, 점점 방문 횟수가 줄어서 결국 O(N) = ElogV + a가 됩니다.\n↩︎ 정점에 비해 간선이 적은 그래프를 희소 그래프라고 합니다.\n해당 문제에서 최대 간선의 숫자는 n * (n - 1) / 2 = 1,249,975,000인 반면, 해당 그래프의 간선의 숫자는 200,000이므로 정점에 비해 간선이 적다고 할 수 있습니다.\n↩︎ ","wordCount":"770","inLanguage":"ko","datePublished":"2025-01-22T10:50:48+09:00","dateModified":"2025-01-22T10:50:48+09:00","author":{"@type":"Person","name":"Leaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leaf-nam.github.io/cote/programmers_118669/"},"publisher":{"@type":"Organization","name":"봄을 기다리는 낙엽","logo":{"@type":"ImageObject","url":"https://leaf-nam.github.io/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/cote/>코딩테스트</a></div><h1 class="post-title entry-hint-parent">[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)</h1><div class=post-description>Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 문제에 대한 해설입니다.</div><div class=post-meta><span title='2025-01-22 10:50:48 +0900 KST'>2025. 1. 22.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;770 단어&nbsp;·&nbsp;Leaf&nbsp;|&nbsp;<a href=https://github.com/leaf-nam/blog/blob/main/content//cote/Programmers_118669/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#출처>출처</a></li><li><a href=#접근>접근</a><ul><li><a href=#문제-분석>문제 분석</a></li><li><a href=#조건-분석>조건 분석</a></li><li><a href=#bfs>BFS</a></li><li><a href=#방문처리-최적화>방문처리 최적화</a></li><li><a href=#도착지-최적화>도착지 최적화</a></li></ul></li><li><a href=#풀이>풀이</a></li><li><a href=#결과>결과</a></li><li><a href=#리뷰>리뷰</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=출처>출처<a hidden class=anchor aria-hidden=true href=#출처>#</a></h2><ul><li><a href=https://school.programmers.co.kr/learn/courses/30/lessons/118669>Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)</a></li></ul><h2 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h2><h3 id=문제-분석>문제 분석<a hidden class=anchor aria-hidden=true href=#문제-분석>#</a></h3><ul><li>산의 봉우리까지 이동하는 과정을 시뮬레이션 하는 문제입니다.</li><li><code>Intensity</code>는 이동 과정에서 가장 긴시간을 뜻합니다.</li><li>문제에서는 정상에 도착한 후, 다시 출입구로 돌아와야 한다고 했지만 <strong>올라갔던 길을 그대로 내려올 수 있기 때문에</strong>, 정상까지만 경로를 추적하면 됩니다.</li><li>따라서 각 출발지(Gate)에서 도착지(Summit)까지의 <code>Intensity</code>가 최소가 되도록 완전탐색을 수행해야 합니다.</li></ul><h3 id=조건-분석>조건 분석<a hidden class=anchor aria-hidden=true href=#조건-분석>#</a></h3><ul><li>문제에서 주어진 정점(Vertex)은 <code>n = 50,000</code> 이고 간선(Edge)은 <code>paths = 200,000</code>입니다.</li><li>탐색의 시작점이 최대 <code>n</code>이기 때문에, <strong>이미 방문한 정점을 필요시에만 재방문하도록 최적화</strong>하면 시간복잡도 내 문제를 해결할 수 있습니다.<blockquote><p>전체 간선을 1회만 탐색할 경우 시간복잡도는 <code>O(N) = E + V = 250,000</code>가 됩니다.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote></li><li>이 때, 정점의 개수에 비해 간선이 적으므로, 인접 리스트를 활용하는 것이 효과적입니다.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup><blockquote><p>간선의 개수가 적은 그래프에서 행렬(<code>n x n matrix</code>)을 사용하게 되면, 불필요한 탐색 및 메모리 초과가 발생할 수 있습니다.</p></blockquote></li></ul><h3 id=bfs>BFS<a hidden class=anchor aria-hidden=true href=#bfs>#</a></h3><ul><li><p>한 정점에서 다른 정점으로 이동 시, 깊이를 따라 이동하면(DFS) 불필요한 탐색이 발생하기 때문에 시간초과가 발생할 수 있습니다.</p><ul><li><p>아래와 같은 깊은 그래프가 있다고 가정하겠습니다.
<img alt=img_3.png loading=lazy src=/cote/programmers_118669/img_3.png></p></li><li><p><code>DFS</code>는 산꼭대기에 도착할때까지 깊이가 계속 깊어지므로, 다음과 같이 깊은 그래프에서는 모든 경로를 탐색하면서 시간복잡도가 계속 증가하게 됩니다.
<img alt=img_2.png loading=lazy src=/cote/programmers_118669/img_2.png></p></li><li><p>그러나 <code>BFS</code>에서는 최단 경로로만 이동하기 때문에 불필요한 탐색을 최적화할 수 있습니다.
<img alt=img_4.png loading=lazy src=/cote/programmers_118669/img_4.png></p></li></ul></li></ul><h3 id=방문처리-최적화>방문처리 최적화<a hidden class=anchor aria-hidden=true href=#방문처리-최적화>#</a></h3><ul><li><p>단순히 방문여부로 방문체크를 한다면, 이후에 더 작은 <code>Intensity</code>로 방문하는 경우를 탐색할 수 없기 때문에, 방문처리 배열은 <code>DP</code> 형태로 <strong>Intensity 최솟값</strong>을 저장해야 합니다.</p></li><li><p>문제에서 주어진 시작점이 여러개이기 때문에, 새로운 시작점에서 서로 다른 <code>BFS</code>를 수행하게 됩니다.</p></li><li><p>그러나, 이전 등산코스에서 방문했던 지점이라면, 새로운 <code>BFS</code>에서 다시 방문할 필요가 없기 때문에 이를 최적화할 수 있습니다.</p><p><img alt=img_5.png loading=lazy src=/cote/programmers_118669/img_5.png></p><ul><li>위와 같이 1번 시작점에서 <code>Intensity = 3</code>으로 방문했던 지점이라면, 3번 시작점에서는 어떻게 해도 <code>Intensity</code>를 줄일 수 없기 때문에 해당 정점은 더이상 방문할 필요가 없습니다.</li></ul></li><li><p>더 나아가서, 탐색 과정에서 해당 정점을 이미 더 작은 가중치로 다시 방문할 필요가 없기 때문에 최적화가 가능합니다.</p></li></ul><blockquote><p>최소 가중치만 방문하는 점에서 다익스트라 알고리즘이 됩니다.</p></blockquote><h3 id=도착지-최적화>도착지 최적화<a hidden class=anchor aria-hidden=true href=#도착지-최적화>#</a></h3><ul><li>도착지를 <code>Set</code>에 삽입하면, 해당 지점이 도착지인지 <code>O(1)</code>로 판단할 수 있기 때문에 도착여부를 빠르게 파악할 수 있습니다.</li><li>이 때, 문제에서 산봉우리 번호가 더 낮은 등산코스를 선택해야 하기 때문에, 더 빠른 도착지점이 앞으로 올 수 있도록 <code>TreeSet</code>으로 구현체를 선택합니다.</li></ul><blockquote><p><code>TreeSet</code>은 내부 원소를 정렬된 형태로 유지합니다.</p></blockquote><h2 id=풀이>풀이<a hidden class=anchor aria-hidden=true href=#풀이>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 정답 초기화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>answer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>10_000_001</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=nf>solution</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>paths</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>gates</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>summits</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 인접리스트 정의 및 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[]&gt;[]</span><span class=w> </span><span class=n>adjList</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>List</span><span class=o>[</span><span class=n>n</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>paths</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>paths</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>paths</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>time</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>paths</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>adjList</span><span class=o>[</span><span class=n>start</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=n>adjList</span><span class=o>[</span><span class=n>start</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>adjList</span><span class=o>[</span><span class=n>end</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=n>adjList</span><span class=o>[</span><span class=n>end</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>adjList</span><span class=o>[</span><span class=n>start</span><span class=o>]</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=n>end</span><span class=p>,</span><span class=w> </span><span class=n>time</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>adjList</span><span class=o>[</span><span class=n>end</span><span class=o>]</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>time</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// DP 형태의 방문배열</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>isVisited</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>n</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Arrays</span><span class=p>.</span><span class=na>fill</span><span class=p>(</span><span class=n>isVisited</span><span class=p>,</span><span class=w> </span><span class=n>10_000_001</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 도착지 Set</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Set</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>summitSet</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>TreeSet</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>summit</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>summits</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>summitSet</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>summit</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 각 시작지점에서 다익스트라 수행</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>start</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>gates</span><span class=p>){</span><span class=w>          
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>dijkstra</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>adjList</span><span class=p>,</span><span class=w> </span><span class=n>isVisited</span><span class=p>,</span><span class=w> </span><span class=n>summitSet</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>answer</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>dijkstra</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[]&gt;[]</span><span class=w> </span><span class=n>adjList</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>isVisited</span><span class=p>,</span><span class=w> </span><span class=n>Set</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>summitSet</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Dijkstra를 위한 PriorityQueue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[]&gt;</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PriorityQueue</span><span class=o>&lt;&gt;</span><span class=p>((</span><span class=n>o1</span><span class=p>,</span><span class=w> </span><span class=n>o2</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>compare</span><span class=p>(</span><span class=n>o1</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>o2</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>isVisited</span><span class=o>[</span><span class=n>start</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>q</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>now</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 탐색 과정에서 더 작은 가중치가 발생한 경우 탐색 종료</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>now</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>isVisited</span><span class=o>[</span><span class=n>now</span><span class=o>[</span><span class=n>0</span><span class=o>]]</span><span class=p>)</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 도착지점일 경우 탐색 종료</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>summitSet</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>now</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>))</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>adjs</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>adjList</span><span class=o>[</span><span class=n>now</span><span class=o>[</span><span class=n>0</span><span class=o>]]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Intensity : 현재 경로에서 가장 긴 시간</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>intensity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>adjs</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 방문체크 : Intensity가 더 작을때만 재방문</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>intensity</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>isVisited</span><span class=o>[</span><span class=n>adjs</span><span class=o>[</span><span class=n>0</span><span class=o>]]</span><span class=p>)</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>isVisited</span><span class=o>[</span><span class=n>adjs</span><span class=o>[</span><span class=n>0</span><span class=o>]]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>intensity</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                         
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 새로운 지점에서 다시 BFS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>q</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=n>adjs</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>intensity</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 산봉우리의 최솟값 찾기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>minSummit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>minIntensity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10_000_001</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// TreeSet이므로 번호가 낮은 산봉우리부터 확인</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>summit</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>summitSet</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 번호가 큰 산봉우리는 Intensity 최솟값이 작을때만 갱신 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>isVisited</span><span class=o>[</span><span class=n>summit</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>minIntensity</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>minIntensity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>isVisited</span><span class=o>[</span><span class=n>summit</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>minSummit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>summit</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 정답 최신화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>answer</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>minIntensity</span><span class=p>)</span><span class=w> </span><span class=o>||</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Intensity가 같으면 번호 확인</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>(</span><span class=n>answer</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>minIntensity</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>answer</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>minSummit</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>answer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=n>minSummit</span><span class=p>,</span><span class=w> </span><span class=n>minIntensity</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=결과>결과<a hidden class=anchor aria-hidden=true href=#결과>#</a></h2><ul><li>소요 시간 : 1시간 30분</li></ul><p><img alt=img_7.png loading=lazy src=/cote/programmers_118669/img_7.png></p><h2 id=리뷰>리뷰<a hidden class=anchor aria-hidden=true href=#리뷰>#</a></h2><ul><li>문제를 정확히 이해하지 않고 구현하려다 보니 구현이 오래 걸렸습니다.</li></ul><blockquote><p>코스에서 가중치가 가장 작은 값만 확인하면 되므로 일반적인 Dijkstra와는 다른 로직임을 나중에야 알게 되었습니다.
문제를 정확히 이해하고 구현하는 습관을 길러야겠습니다.</p></blockquote><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><table><thead><tr><th style=text-align:left>URL</th><th style=text-align:left>게시일자</th><th style=text-align:left>방문일자</th><th style=text-align:left>작성자</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://ko.wikipedia.org/wiki/%EB%B0%80%EC%A7%91_%EA%B7%B8%EB%9E%98%ED%94%84>희소 그래프</a></td><td style=text-align:left>2023.04.01.</td><td style=text-align:left>2025.01.22.</td><td style=text-align:left>Wikipedia</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>물론 문제에서 각 정점을 1번씩만 방문하지는 않겠지만, 이미 방문한 정점을 특정 조건에서만 방문하도록 최적화하면 유사한 시간복잡도 내에서 탐색이 가능합니다.</p><blockquote><p>다익스트라를 사용하면 시작점 1개의 탐색횟수는 <code>O(N) = ElogV = paths * log(n) = 3,122,000</code>가 되지만, 다음 시작점의 탐색에서는 방문 배열을 통해 필요한 정점만 재방문하므로, 점점 방문 횟수가 줄어서 결국 <code>O(N) = ElogV + a</code>가 됩니다.</p></blockquote>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:2><p>정점에 비해 간선이 적은 그래프를 <a href=https://ko.wikipedia.org/wiki/%EB%B0%80%EC%A7%91_%EA%B7%B8%EB%9E%98%ED%94%84>희소 그래프</a>라고 합니다.</p><blockquote><p>해당 문제에서 최대 간선의 숫자는 <code>n * (n - 1) / 2 = 1,249,975,000</code>인 반면, 해당 그래프의 간선의 숫자는 <code>200,000</code>이므로 정점에 비해 간선이 적다고 할 수 있습니다.</p></blockquote>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://leaf-nam.github.io/tags/codingtest/>Codingtest</a></li><li><a href=https://leaf-nam.github.io/tags/programmers/>Programmers</a></li><li><a href=https://leaf-nam.github.io/tags/bfs/>BFS</a></li></ul><nav class=paginav><a class=prev href=https://leaf-nam.github.io/cote/programmers_150366/><span class=title>« 이전 페이지</span><br><span>[Java]Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT)</span>
</a><a class=next href=https://leaf-nam.github.io/cote/swea_1249/><span class=title>다음 페이지 »</span><br><span>[Java]SWEA 1249 보급로</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on x" href="https://x.com/intent/tweet/?text=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29&amp;url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f&amp;hashtags=codingtest%2cprogrammers%2cBFS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f&amp;title=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29&amp;summary=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29&amp;source=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f&title=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on whatsapp" href="https://api.whatsapp.com/send?text=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29%20-%20https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on telegram" href="https://telegram.me/share/url?text=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29&amp;url=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bJava%5dProgrammers%20%eb%93%b1%ec%82%b0%ec%bd%94%ec%8a%a4%20%ec%a0%95%ed%95%98%ea%b8%b0%282022%20KAKAO%20TECH%20INTERNSHIP%29&u=https%3a%2f%2fleaf-nam.github.io%2fcote%2fprogrammers_118669%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=leaf-nam/leaf-nam.github.io issue-term=title theme=boxy-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>