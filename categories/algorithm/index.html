<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm | 봄을 기다리는 낙엽</title>
<meta name=keywords content><meta name=description content="봄을 기다리는 낙엽의 기술 블로그"><meta name=author content="map[email:spearoad15@gmail.com name:Sangyeop Nam]"><link rel=canonical href=https://1eaf.site/categories/algorithm/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://1eaf.site/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://1eaf.site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://1eaf.site/favicon-32x32.png><link rel=apple-touch-icon href=https://1eaf.site/apple-touch-icon.png><link rel=mask-icon href=https://1eaf.site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://1eaf.site/categories/algorithm/index.xml><link rel=alternate hreflang=ko href=https://1eaf.site/categories/algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://1eaf.site/categories/algorithm/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="Algorithm"><meta property="og:description" content="봄을 기다리는 낙엽의 기술 블로그"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Algorithm"><meta name=twitter:description content="봄을 기다리는 낙엽의 기술 블로그"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://1eaf.site/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://1eaf.site/search/ title=검색><span>검색</span></a></li><li><a href=https://1eaf.site/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://1eaf.site/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://1eaf.site/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://1eaf.site/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://1eaf.site/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://1eaf.site/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://1eaf.site/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://1eaf.site/>홈</a>&nbsp;»&nbsp;<a href=https://1eaf.site/categories/>Categories</a></div><h1>Algorithm
<a href=/categories/algorithm/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)</h2></header><div class=entry-content><p>출처 Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 접근 문제 분석 산의 봉우리까지 이동하는 과정을 시뮬레이션 하는 문제입니다. Intensity는 이동 과정에서 가장 긴시간을 뜻합니다. 문제에서는 정상에 도착한 후, 다시 출입구로 돌아와야 한다고 했지만 올라갔던 길을 그대로 내려올 수 있기 때문에, 정상까지만 경로를 추적하면 됩니다. 따라서 각 출발지(Gate)에서 도착지(Summit)까지의 Intensity가 최소가 되도록 완전탐색을 수행해야 합니다. 조건 분석 문제에서 주어진 정점(Vertex)은 n = 50,000 이고 간선(Edge)은 paths = 200,000입니다. 탐색의 시작점이 최대 n이기 때문에, 각 간선을 1번씩만 방문하도록 최적화하면 시간복잡도 내 문제를 해결할 수 있습니다. O(N) = n + paths = 250,000
...</p></div><footer class=entry-footer><span title='2025-01-22 10:50:48 +0900 KST'>2025. 1. 22.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;661 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)" href=https://1eaf.site/cote/programmers_118669/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]SWEA 1249 보급로</h2></header><div class=entry-content><p>출처 SWEA 1249 보급로 접근 시간복잡도 계산 N &lt;= 100, 지도의 최대 크기가 10000이므로, 방문 체크만 잘 해주면 완전탐색을 하는데 큰 문제가 없는 조건입니다. BFS BFS(너비우선 탐색)를 통해 최단경로를 구할 수 있습니다.
이 때, 미로찾기 알고리즘처럼 목적지에 도착하면 끝나는 것이 아니라, 가중치가 가장 낮은 경로로 이동해야 합니다.
따라서, 이미 목적지에 도착했더라도 더 빠른 경로가 있기 때문에 BFS를 종료하면 안됩니다.
위 그림에서 우 -> 하 순으로 탐색을 진행할 경우, 전체 비용이 6인 경로가 먼저 탐색되지만 비용이 가장 작은 경로는 아닙니다. 이를 위해, 각 지점마다 도달할 수 있는 최소 가중치를 저장해두고, 해당 가중치보다 작은 값만 재방문이 가능하도록 하여 방문 횟수를 줄일 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-01-13 09:47:57 +0900 KST'>2025. 1. 13.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;823 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]SWEA 1249 보급로" href=https://1eaf.site/cote/swea_1249/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 산 모양 타일링(2024 KAKAO WINTER INTERNSHIP)</h2></header><div class=entry-content><p>출처 2024 KAKAO WINTER INTERNSHIP 산 모양 타일링 접근 시간복잡도 구하기 n &lt;= 100,000 이므로 전체 타일의 개수는 최대 사다리꼴의 윗변의 모든 자리에 삼각형을 넣을 수 있으므로 2n + 1 + n &lt;= 300,001개 입니다.
이러한 삼각형의 배치를 완전탐색으로 구하는 것은 불가능하기 때문에, DP를 통한 최적화가 필요합니다.
규칙성 찾기 예제의 타일을 1칸씩 세면서 경우의 수를 세면 규칙성을 확인할 수 있습니다.
다음과 같이 (1 ~ 9) 순으로 예제타일의 규칙성을 구해보겠습니다.
...</p></div><footer class=entry-footer><span title='2025-01-07 13:47:29 +0900 KST'>2025. 1. 7.</span>&nbsp;·&nbsp;2 분&nbsp;·&nbsp;362 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 산 모양 타일링(2024 KAKAO WINTER INTERNSHIP)" href=https://1eaf.site/cote/programmers_258705/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]백준 17470 배열 돌리기 5</h2></header><div class=entry-content><p>출처 https://www.acmicpc.net/problem/17470 접근 시간복잡도 분석 문제에서 주어진 배열의 크기는 최대 100 x 100이고, 전체 연산의 개수는 2,000,000개 이므로, 일반적인 회전을 구현할 경우 시간 초과가 발생합니다.
O(N) = 100 x 100 x 2,000,000 = 2 x 10^13입니다.
배열 연산 압축하기(X) 해당 접근은 잘못된 풀이입니다. 올바른 풀이는 아래를 참고하시기 바랍니다.
연산을 구현하고 배열을 돌리다 보면, 뭔가 최적화할 수 있는 것 같은 느낌이 듭니다.
상하(1)-좌우(2) 반전
2번 하면 원래 배열로 복귀합니다. 오른쪽(3) 왼쪽(4) 회전
...</p></div><footer class=entry-footer><span title='2024-12-31 09:49:24 +0900 KST'>2024. 12. 31.</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;1273 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]백준 17470 배열 돌리기 5" href=https://1eaf.site/cote/bj_17470/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 멀쩡한 사각형</h2></header><div class=entry-content><p>출처 프로그래머스 멀쩡한 사각형 접근 규칙을 알고 나면 구하기 쉽지만, 모르면 생각보다 까다로운 문제입니다.
규칙 구하기 주어진 예시 (w = 8, h = 12)에 대해 규칙을 확인해보겠습니다.
문제의 예시를 자세히 보면 작은 사각형이 반복되는 것을 알 수 있습니다. w = 8과 h = 12의 최대공약수인 4개의 사각형이 생성됩니다.
즉, 최대공약수로 해당 길이를 나누었을 때 생성된 작은 사각형의 잘린 개수를 구하면 됩니다.
최대공약수로 나눠진 사각형(nw x nh = 2 x 3)의 잘린 개수는 다음과 같이 구할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-12-23 15:51:25 +0900 KST'>2024. 12. 23.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;442 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 멀쩡한 사각형" href=https://1eaf.site/cote/programmers_62048/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://1eaf.site/categories/algorithm/page/2/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://1eaf.site/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>