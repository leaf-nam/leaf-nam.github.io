<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementation | 봄을 기다리는 낙엽</title>
<meta name=keywords content><meta name=description content="봄을 기다리는 낙엽의 기술 블로그"><meta name=author content="map[email:spearoad15@gmail.com name:Sangyeop Nam]"><link rel=canonical href=https://1eaf.site/tags/implementation/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://1eaf.site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://1eaf.site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://1eaf.site/favicon-32x32.png><link rel=apple-touch-icon href=https://1eaf.site/apple-touch-icon.png><link rel=mask-icon href=https://1eaf.site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://1eaf.site/tags/implementation/index.xml><link rel=alternate hreflang=ko href=https://1eaf.site/tags/implementation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://1eaf.site/tags/implementation/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="Implementation"><meta property="og:description" content="봄을 기다리는 낙엽의 기술 블로그"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementation"><meta name=twitter:description content="봄을 기다리는 낙엽의 기술 블로그"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://1eaf.site/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://1eaf.site/search/ title=검색><span>검색</span></a></li><li><a href=https://1eaf.site/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://1eaf.site/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://1eaf.site/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://1eaf.site/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://1eaf.site/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://1eaf.site/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://1eaf.site/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://1eaf.site/>홈</a>&nbsp;»&nbsp;<a href=https://1eaf.site/tags/>Tags</a></div><h1>Implementation
<a href=/tags/implementation/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]백준 17470 배열 돌리기 5</h2></header><div class=entry-content><p>출처 https://www.acmicpc.net/problem/17470 접근 시간복잡도 분석 문제에서 주어진 배열의 크기는 최대 100 x 100이고, 전체 연산의 개수는 2,000,000개 이므로, 일반적인 회전을 구현할 경우 시간 초과가 발생합니다.
O(N) = 100 x 100 x 2,000,000 = 2 x 10^13입니다.
배열 연산 압축하기(X) 해당 접근은 잘못된 풀이입니다. 올바른 풀이는 아래를 참고하시기 바랍니다.
연산을 구현하고 배열을 돌리다 보면, 뭔가 최적화할 수 있는 것 같은 느낌이 듭니다.
상하(1)-좌우(2) 반전
2번 하면 원래 배열로 복귀합니다. 오른쪽(3) 왼쪽(4) 회전
...</p></div><footer class=entry-footer><span title='2024-12-31 09:49:24 +0900 KST'>2024. 12. 31.</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;1273 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]백준 17470 배열 돌리기 5" href=https://1eaf.site/cote/bj_17470/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]코드트리 메두사와 전사들 문제 해설</h2></header><div class=entry-content><p>출처 메두사와 전사들 접근 복잡한 문제인만큼 구현하면서 순차적으로 처리해야 할 과정이 많은데, 이에 필요한 알고리즘을 정리해보면 다음과 같습니다.
메두사의 이동경로 구현 BFS + 경로 역추적 시선 생성 배열 탐색 구현 병사 이동 및 공격 배열 탐색 구현 알고리즘 자체는 어렵지 않으나, 배열 탐색을 구현하는 과정이 복잡합니다.
메두사 이동경로 구현(BFS) 메두사가 이동하는 과정에 장애물이 있기 때문에, BFS를 통해 미로를 탐색하는 최단경로를 구해야 합니다.
또한, 이동경로를 다시 돌면서 병사들과의 상호작용을 확인하기 위해 이러한 경로를 별도 배열에 저장해야 합니다.
...</p></div><footer class=entry-footer><span title='2024-12-21 10:01:55 +0900 KST'>2024. 12. 21.</span>&nbsp;·&nbsp;15 분&nbsp;·&nbsp;3020 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]코드트리 메두사와 전사들 문제 해설" href=https://1eaf.site/cote/codetree_medusa_and_warriors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 수식 최대화(2020 KAKAO Internship)</h2></header><div class=entry-content><p>출처 수식 최대화(2020 KAKAO Internship) 접근 완전탐색(DFS) 각 연산자의 우선순위를 변경하면서 전체 탐색을 하고, 변경된 우선순위마다 수식을 계산해서 최댓값을 갱신합니다.
연산자 순서에 따라 결과가 달라지므로, 순열(Permutation)에 해당합니다. 다양한 구현방법이 있지만, 개인적으로 다양한 조건을 만족하는 순열(조합)을 빠르게 구현할 수 있는 DFS를 선호합니다.
3가지 연산자만 있으므로, 모든 경우의 수를 구해도 6가지이기 때문에 시간복잡도는 충분합니다. 후위 표기 변환(InFix to PostFix) 보통 사람이 계산을 할 때는 A + B * C의 형태로 수식을 써서 계산을 합니다. 이 때, A와 B 사이에 연산자가 있는 형태를 중위 표기(InFix)라고 합니다.
...</p></div><footer class=entry-footer><span title='2024-12-18 09:23:36 +0900 KST'>2024. 12. 18.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;817 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 수식 최대화(2020 KAKAO Internship)" href=https://1eaf.site/cote/programmers_67257/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 2개 이하로 다른 비트</h2></header><div class=entry-content><p>출처 Programmers 2개 이하로 다른 비트 접근 완전탐색 가장 직관적인 풀이는 주어진 숫자를 1씩 증가시키면서 현재 비트와의 개수 차이를 구하는 것입니다. 그러나 이렇게 풀이하면 주어진 조건에서 시간복잡도가 초과합니다. numbers[i] &lt;= 10^15 == 2^501이므로 50개의 비트열로 표현되는데, 비트를 비교하는 과정에서 숫자가 1개 증가할 때마다 50^2 = 2500의 시간복잡도가 소모됩니다.2
규칙성 찾기 완전탐색은 불가능하니 두 비트 중 다른 지점이 2개 이하이면서 가장 작은 수를 찾는 규칙을 찾아야 합니다. 현재 숫자와 다음 숫자의 이진수의 비트차이가 커지는 순간을 생각해보면, 맨 뒤에서부터 1이 쌓여있을 때 1을 더하면 비트차이가 크게 발생합니다. 255에서 256으로 증가하는 시점의 비트 차이
...</p></div><footer class=entry-footer><span title='2024-11-14 10:00:18 +0900 KST'>2024. 11. 14.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;507 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 2개 이하로 다른 비트" href=https://1eaf.site/cote/programmers_77885/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]HackerRank Gridland Metro</h2></header><div class=entry-content><p>출처 해커 랭크 : Gridland Metro 문제 설명 영문 사이트이므로 문제를 간단히 설명하겠습니다.
가로등을 설치해야 하는데, 철도가 있는 지점에는 가로등을 설치할 수 없습니다. 철도는 가로로만 설치되며, 철도끼리는 겹칠 수 있습니다. 문제에는 철도의 개수(k)와 철도의 시작점(r, c1)과 끝점(r, c2)이 주어지며, 이 때 가로등을 설치할 수 있는 지점의 개수를 구해야 합니다. 접근 시간복잡도 계산 철도의 개수 k &lt;= 1000인 반면 전체 좌표의 크기 (n, m) &lt; 10^9 입니다. 따라서 각 좌표를 한번씩 방문하는 것은 불가능하며 주어진 철도의 범위로 문제를 해결해야 합니다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:04:47 +0900 KST'>2024. 11. 13.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;591 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]HackerRank Gridland Metro" href=https://1eaf.site/cote/hackerrank_gridland_metro/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://1eaf.site/tags/implementation/page/2/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://1eaf.site/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>