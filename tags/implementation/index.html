<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementation | 봄을 기다리는 낙엽</title>
<meta name=keywords content><meta name=description content="봄을 기다리는 낙엽의 기술 블로그"><meta name=author content="map[email:spearoad15@gmail.com name:Sangyeop Nam]"><link rel=canonical href=https://leaf-nam.github.io/tags/implementation/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://leaf-nam.github.io/tags/implementation/index.xml><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/tags/implementation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/tags/implementation/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="Implementation"><meta property="og:description" content="봄을 기다리는 낙엽의 기술 블로그"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementation"><meta name=twitter:description content="봄을 기다리는 낙엽의 기술 블로그"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/tags/>Tags</a></div><h1>Implementation
<a href=/tags/implementation/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 봉인된 주문</h2></header><div class=entry-content><p>출처 프로그래머스 봉인된 주문 접근 문제 분석 알파벳 순으로 정렬된 주문서에서 주어진 숫자(n)에 해당하는 주문서를 찾는 문제입니다. 이 때, 특정 주문(bans)이 삭제되어 있는 상태입니다. 시간복잡도 분석 주어진 숫자는 n = 10^15 인 long 타입의 숫자입니다. 따라서 해당 숫자에서 글자를 가져오는 알고리즘은 O(N)보다 작아야 합니다.
주어진 주문인 bans는 길이가 300,000이하입니다. 또한, 각 주문의 길이는 최대 11입니다. 모든 주문의 알파벳을 비교하기 위해서는 300,000 x 300,000(주문 간 비교) x 11(주문 길이) = 9x10^12 x 11 이므로 시간복잡도가 초과될 가능성이 있습니다. 따라서 전체 주문을 최대 O(NlogN)까지 확인할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-03-17 16:02:10 +0900 KST'>2025. 3. 17.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;527 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 봉인된 주문" href=https://leaf-nam.github.io/cote/programmers_389481/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 자물쇠와 열쇠(2020 KAKAO BLIND RECRUITMENT)</h2></header><div class=entry-content><p>출처 Programmers 자물쇠와 열쇠(2020 KAKAO BLIND RECRUITMENT) 접근 문제 분석 주어진 자물쇠와 열쇠를 이동시키고 돌려서 맞출 수 있는지 확인하는 문제입니다.
열쇠 혹은 자물쇠를 돌리는 로직과, 이동시키는 로직을 구현하면 됩니다. 문제에서 주어진 열쇠보다 자물솨의 크기가 작기 때문에, 자물쇠를 이동시키고 돌리는 식으로 구현하는 것이 더 효율적입니다.
모든 칸에 대해서 자물쇠를 돌리면서 맞추고, 이동하는 식으로 완전탐색을 진행합니다. 시간복잡도 분석 자물쇠와 열쇠의 크기는 M &lt;= N &lt;= 20이므로, 전체 칸의 개수는 M^2 &lt;= N^2 &lt;= 400입니다.
...</p></div><footer class=entry-footer><span title='2025-02-10 12:14:05 +0900 KST'>2025. 2. 10.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;748 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 자물쇠와 열쇠(2020 KAKAO BLIND RECRUITMENT)" href=https://leaf-nam.github.io/cote/programmers_60059/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT)</h2></header><div class=entry-content><p>출처 Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT) 접근 문제 분석 표 편집 프로그램의 기능을 구현해야 합니다. UPDATE : 셀 1개의 값 바꾸기, 모든 셀의 값 찾아 바꾸기 MERGE : 셀 합치기(그룹화) UNMERGE : 셀 분리하기(그룹화 해제) PRINT : 셀 1개의 값 출력하기 표의 크기가 50 x 50이고, 명령의 길이가 1000 이하이므로, 시간복잡도는 충분한 편입니다. UPDATE는 비교적 쉽게 구현할 수 있지만, 문제의 이름처럼 표 병합을 얼마나 정확하고 빠르게 구현하는지가 중요한 문제입니다.
...</p></div><footer class=entry-footer><span title='2025-02-05 09:55:04 +0900 KST'>2025. 2. 5.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;604 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT)" href=https://leaf-nam.github.io/cote/programmers_150366/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]백준 17470 배열 돌리기 5</h2></header><div class=entry-content><p>출처 https://www.acmicpc.net/problem/17470 접근 시간복잡도 분석 문제에서 주어진 배열의 크기는 최대 100 x 100이고, 전체 연산의 개수는 2,000,000개 이므로, 일반적인 회전을 구현할 경우 시간 초과가 발생합니다.
O(N) = 100 x 100 x 2,000,000 = 2 x 10^13입니다.
배열 연산 압축하기(X) 해당 접근은 잘못된 풀이입니다. 올바른 풀이는 아래를 참고하시기 바랍니다.
연산을 구현하고 배열을 돌리다 보면, 뭔가 최적화할 수 있는 것 같은 느낌이 듭니다.
상하(1)-좌우(2) 반전
2번 하면 원래 배열로 복귀합니다. 오른쪽(3) 왼쪽(4) 회전
...</p></div><footer class=entry-footer><span title='2024-12-31 09:49:24 +0900 KST'>2024. 12. 31.</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;1273 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]백준 17470 배열 돌리기 5" href=https://leaf-nam.github.io/cote/bj_17470/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]코드트리 메두사와 전사들 문제 해설</h2></header><div class=entry-content><p>출처 메두사와 전사들 접근 복잡한 문제인만큼 구현하면서 순차적으로 처리해야 할 과정이 많은데, 이에 필요한 알고리즘을 정리해보면 다음과 같습니다.
메두사의 이동경로 구현 BFS + 경로 역추적 시선 생성 배열 탐색 구현 병사 이동 및 공격 배열 탐색 구현 알고리즘 자체는 어렵지 않으나, 배열 탐색을 구현하는 과정이 복잡합니다.
메두사 이동경로 구현(BFS) 메두사가 이동하는 과정에 장애물이 있기 때문에, BFS를 통해 미로를 탐색하는 최단경로를 구해야 합니다.
또한, 이동경로를 다시 돌면서 병사들과의 상호작용을 확인하기 위해 이러한 경로를 별도 배열에 저장해야 합니다.
...</p></div><footer class=entry-footer><span title='2024-12-21 10:01:55 +0900 KST'>2024. 12. 21.</span>&nbsp;·&nbsp;15 분&nbsp;·&nbsp;3020 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]코드트리 메두사와 전사들 문제 해설" href=https://leaf-nam.github.io/cote/codetree_medusa_and_warriors/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://leaf-nam.github.io/tags/implementation/page/2/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>