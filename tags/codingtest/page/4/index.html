<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Codingtest | 봄을 기다리는 낙엽</title>
<meta name=keywords content><meta name=description content="봄을 기다리는 낙엽의 기술 블로그"><meta name=author content="map[email:spearoad15@gmail.com name:Sangyeop Nam]"><link rel=canonical href=https://leaf-nam.github.io/tags/codingtest/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://leaf-nam.github.io/tags/codingtest/index.xml><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/tags/codingtest/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/tags/codingtest/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="Codingtest"><meta property="og:description" content="봄을 기다리는 낙엽의 기술 블로그"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Codingtest"><meta name=twitter:description content="봄을 기다리는 낙엽의 기술 블로그"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/tags/>Tags</a></div><h1>Codingtest
<a href=/tags/codingtest/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]백준 9202 Boggle</h2></header><div class=entry-content><p>출처 백준 9202 Boggle
접근 Backtracking 특정 단어를 한 글자씩 찾아들어가면서 단어 사전에 존재하는지 확인하는 방식은 전형적인 DFS의 형태입니다.
주어진 단어의 개수가 w &lt; 300,000 이지만 탐색해야 하는 전체 Boggle 보드의 크기가 4X4이고, 이러한 Boggle의 개수가 b &lt; 30이기 때문에 DFS 자체는 많은 시간복잡도가 필요하지 않습니다. DFS 탐색 과정에서 다음 글자를 추가했을 때, 단어 사전에 포함된 단어를 만들 수 있는지를 빠르게 확인하여 불가능한 경우를 가지치기(pruning)한다면, 시간복잡도를 더욱 줄일 수 있습니다. 이러한 기법을 Backtracking이라고 합니다.
...</p></div><footer class=entry-footer><span title='2024-12-10 13:51:29 +0900 KST'>2024. 12. 10.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;821 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]백준 9202 Boggle" href=https://leaf-nam.github.io/cote/bj_9202/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 순위 검색(2021 KAKAO BLIND RECRUITMENT)</h2></header><div class=entry-content><p>출처 2021 KAKAO BLIND RECRUITMENT 순위 검색 접근 와일드카드 검색 와일드카드(-) 없이 검색을 구현하는 것은 각 지원자의 속성에 코딩테스트 점수를 저장하면, 속성별로 검색이 가능하기 때문에 큰 어려움이 없습니다.
와일드카드가 없는 상황은 다음과 같이 트리 구조로 데이터를 저장할 수 있습니다. 트리 구조로 지원자 정보를 저장합니다. 리프 노드에는 리스트로 코딩테스트 점수를 저장합니다.
하지만, 문제에서 주어진 것처럼 쿼리 시 와일드카드가 나오면 모든 정보를 포함하도록 탐색을 해야 하기 때문에 이를 구현하기 위해 별도의 공간에 와일드카드 속성들을 저장해야 합니다.
...</p></div><footer class=entry-footer><span title='2024-12-04 12:55:12 +0900 KST'>2024. 12. 4.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;529 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 순위 검색(2021 KAKAO BLIND RECRUITMENT)" href=https://leaf-nam.github.io/cote/programmers_72412/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]백준 14942 개미</h2></header><div class=entry-content><p>출처 백준 개미 접근 완전탐색(DFS) 자식 방에서 부모(Root) 방향으로 DFS를 하면서 지상에 도달하는데 걸리는 시간을 확인합니다.
개미 방의 개수가 최대 10^5이므로, 최악의 경우인 방이 일렬로 나열된 경우를 고려해야 합니다.1 선형적인 DFS로는 시간복잡도가 초과할 것이라고 생각해서 BinarySearch로 최적화를 했는데, 선형으로 조상들을 탐색해도 시간초과가 되지 않는 것으로 보아 DFS 만으로도 풀 수 있을 것 같습니다.
TREE + BinarySearch 문제를 다시 읽어보면 자신 부모들의 집합, 즉, 조상들을 하나씩 타고 올라가면서 갈 수 있는 최대 조상의 번호를 반환해야 함을 알 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-12-03 17:20:52 +0900 KST'>2024. 12. 3.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;762 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]백준 14942 개미" href=https://leaf-nam.github.io/cote/bj_14942/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 숫자 타자 대회</h2></header><div class=entry-content><p>출처 프로그래머스 숫자 타자 대회 접근 완전탐색 이전 숫자에서 왼손과 오른손을 움직여서 다음 숫자를 누르는 모든 경우를 방문하게 되면 매번 2번씩 방문이 발생합니다.
1,000개의 숫자를 왼손과 오른손으로 모두 누르려면 2^1000의 시간복잡도가 필요합니다.1 이는 불가능하므로, 완전탐색만으로는 풀이할 수 없습니다.
DP 문제에서 필요한 값은 최솟값이니, 완전탐색 중 최솟값들만을 저장하면서 계산하면 100*1000 = 10^6으로 시간복잡도를 줄일 수 있습니다.
이전 값들 중 최솟값만 저장하면서 완전탐색을 최적화합니다.
위 과정을 자세히 살펴보면, 처음 위치[l : 4], [r : 6]에서 0번 패드를 누르려면 2가지 경우가 발생합니다. 이 경우에는 중복되는 가짓수가 없으니 진행합니다. 다음 위치[l : 0, 4], [r : 6, 0]에서 1번 패드를 누르려면 각각 2가지씩 총 4가지 경우가 발생합니다. 이 경우에도 중복되는 가짓수가 없으니 진행합니다. 다음 위치[l : 1, 1, 0, 4], [r : 6, 0, 1, 1]에서 3번 패드를 누르려면 각각 4가지씩 총 8가지 경우가 발생합니다. 이 경우 더 작은 값만을 저장하여 가지치기가 가능합니다. 좀 더 자세히 살펴보기 위해, 다른 경우는 제외하고 첫번째 중복의 경우만 추적해보겠습니다. 두 경우의 총 가중치를 비교해서 작은 값만을 남깁니다.
...</p></div><footer class=entry-footer><span title='2024-11-28 09:14:35 +0900 KST'>2024. 11. 28.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;831 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 숫자 타자 대회" href=https://leaf-nam.github.io/cote/programmers_136797/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 혼자 놀기의 달인</h2></header><div class=entry-content><p>출처 프로그래머스 혼자 놀기의 달인 접근 숫자 더미를 여러 그룹으로 분리한 뒤, 가장 큰 그룹과 두번째로 큰 그룹을 선택합니다.
완전탐색(DFS) DFS를 통해 숫자 더미를 여러 그룹으로 분리할 수 있습니다.
문제에서 주어진 카드의 최대 개수가 100 이하이므로, 한번씩 방문한다면 O(N)으로 해결이 가능합니다. 100개의 카드가 1개의 그룹인 경우, DFS의 최대 Depth가 100이므로 재귀 호출을 하더라도 StackOverFlow1가 발생하지 않습니다.
재귀 호출을 통해 그룹 분리하기
풀이 import java.util.*; class Solution { // 카드 그룹을 넣을 전역변수 List&lt;Integer> group; public int solution(int[] cards) { group = new ArrayList&lt;>(); // 방문 체크를 위한 변수 boolean[] visited = new boolean[cards.length + 1]; // 카드를 돌면서 그룹화 for (int card : cards) { // 이미 방문한 카드는 다시 방문하지 않음 if (visited[card]) continue; // DFS dfs(card, 0, cards, visited); } // 그룹이 1개면 0 반환 if (group.size() == 1) return 0; // 내림차순 정렬 후 가장 큰 그룹과 두번째로 큰 그룹 곱해서 반환 group.sort(Comparator.reverseOrder()); return group.get(0) * group.get(1); } // DFS void dfs(int now, int cnt, int[] cards, boolean[] visited) { // 이미 방문한 그룹이 다시 등장 -> 같은 사이클(그룹)이므로 그룹에 현재 개수 추가 if (visited[now]) { group.add(cnt); return; } // 방문 체크 visited[now] = true; // now에서 1을 빼줘야 배열 범위를 벗어나지 않음, 방문할 때마다 현재 그룹의 개수 1개씩 추가 dfs(cards[now - 1], cnt + 1, cards, visited); } } 결과 소요시간 7:41 ...</p></div><footer class=entry-footer><span title='2024-11-25 08:57:41 +0900 KST'>2024. 11. 25.</span>&nbsp;·&nbsp;2 분&nbsp;·&nbsp;315 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 혼자 놀기의 달인" href=https://leaf-nam.github.io/cote/programmers_131130/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://leaf-nam.github.io/tags/codingtest/page/3/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://leaf-nam.github.io/tags/codingtest/page/5/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>