<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programmers | 봄을 기다리는 낙엽</title>
<meta name=keywords content><meta name=description content="봄을 기다리는 낙엽의 기술 블로그"><meta name=author content="map[email:spearoad15@gmail.com name:Sangyeop Nam]"><link rel=canonical href=https://leaf-nam.github.io/tags/programmers/><meta name=google-site-verification content="l76eAEMadEn1QzS8fLTbrl8ppayZprvV3uuAbMGSy_c"><meta name=msvalidate.01 content="XYZabc"><meta name=naver-site-verification content="adff811404d441495a954e30579f40297ba14f5e"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://leaf-nam.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://leaf-nam.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leaf-nam.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://leaf-nam.github.io/apple-touch-icon.png><link rel=mask-icon href=https://leaf-nam.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://leaf-nam.github.io/tags/programmers/index.xml><link rel=alternate hreflang=ko href=https://leaf-nam.github.io/tags/programmers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9PNFP00SSG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9PNFP00SSG")}</script><meta property="og:url" content="https://leaf-nam.github.io/tags/programmers/"><meta property="og:site_name" content="봄을 기다리는 낙엽"><meta property="og:title" content="Programmers"><meta property="og:description" content="봄을 기다리는 낙엽의 기술 블로그"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Programmers"><meta name=twitter:description content="봄을 기다리는 낙엽의 기술 블로그"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leaf-nam.github.io/ accesskey=h title="LEAF (Alt + H)">LEAF</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leaf-nam.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://leaf-nam.github.io/posts/ title=게시글><span>게시글</span></a></li><li><a href=https://leaf-nam.github.io/tips/ title=미세팁><span>미세팁</span></a></li><li><a href=https://leaf-nam.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://leaf-nam.github.io/cote/ title=알고리즘><span>알고리즘</span></a></li><li><a href=https://leaf-nam.github.io/review/ title="책 리뷰"><span>책 리뷰</span></a></li><li><a href=https://leaf-nam.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://leaf-nam.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://github.com/leaf-nam/blog title=Git><span>Git</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://leaf-nam.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://leaf-nam.github.io/tags/>Tags</a></div><h1>Programmers
<a href=/tags/programmers/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 110 옮기기</h2></header><div class=entry-content><p>출처 프로그래머스 110 옮기기
접근 문제 분석 주어진 이진 문자열에서 110이라는 문자열을 이동시켜야 하는 문제입니다. 문자열에서 110을 제거한 뒤, 새로운 위치에 얼마나 빨리 삽입할 수 있는지가 포인트입니다. 주어진 문자열의 길이는 1,000,000으로, O(N)혹은 O(NlogN) 이내의 시간복잡도를 구현해야 합니다. 퓰이 우선 문제에서 주어진대로 110을 옮겨야 하기 때문에, 우선 110을 모두 제거하고 그 개수를 저장해야 합니다.
110 제거 그러나 문자열에서 110을 제거하는 과정이 만만치 않습니다.
문자열에서 단순히 110이라는 글자를 찾아 삭제하면 끝일 것 같지만, 다음과 같은 경우에는 한번에 끝나지 않습니다. 다음과 같이 문자열이 주어졌다고 가정해보겠습니다. 문자열에서 110을 제거하면, 다시 110이라는 문자열이 나타납니다. 따라서, 문자열에서 110이 나타나지 않을 때까지 110을 제거해야 합니다. 또한, 단순히 제거만 하는게 아니라 제거한 횟수를 별도로 저장해야 합니다.
...</p></div><footer class=entry-footer><span title='2025-02-05 11:21:43 +0900 KST'>2025. 2. 5.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;609 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 110 옮기기" href=https://leaf-nam.github.io/cote/programmers_77886/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT)</h2></header><div class=entry-content><p>출처 Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT) 접근 문제 분석 표 편집 프로그램의 기능을 구현해야 합니다. UPDATE : 셀 1개의 값 바꾸기, 모든 셀의 값 찾아 바꾸기 MERGE : 셀 합치기(그룹화) UNMERGE : 셀 분리하기(그룹화 해제) PRINT : 셀 1개의 값 출력하기 표의 크기가 50 x 50이고, 명령의 길이가 1000 이하이므로, 시간복잡도는 충분한 편입니다. UPDATE는 비교적 쉽게 구현할 수 있지만, 문제의 이름처럼 표 병합을 얼마나 정확하고 빠르게 구현하는지가 중요한 문제입니다.
...</p></div><footer class=entry-footer><span title='2025-02-05 09:55:04 +0900 KST'>2025. 2. 5.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;604 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 표 병합(2023 KAKAO BLIND RECRUITMENT)" href=https://leaf-nam.github.io/cote/programmers_150366/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)</h2></header><div class=entry-content><p>출처 Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP) 접근 문제 분석 산의 봉우리까지 이동하는 과정을 시뮬레이션 하는 문제입니다. Intensity는 이동 과정에서 가장 긴시간을 뜻합니다. 문제에서는 정상에 도착한 후, 다시 출입구로 돌아와야 한다고 했지만 올라갔던 길을 그대로 내려올 수 있기 때문에, 정상까지만 경로를 추적하면 됩니다. 따라서 각 출발지(Gate)에서 도착지(Summit)까지의 Intensity가 최소가 되도록 완전탐색을 수행해야 합니다. 조건 분석 문제에서 주어진 정점(Vertex)은 n = 50,000 이고 간선(Edge)은 paths = 200,000입니다. 탐색의 시작점이 최대 n이기 때문에, 이미 방문한 정점을 필요시에만 재방문하도록 최적화하면 시간복잡도 내 문제를 해결할 수 있습니다. 전체 간선을 1회만 탐색할 경우 시간복잡도는 O(N) = E + V = 250,000가 됩니다.1
...</p></div><footer class=entry-footer><span title='2025-01-22 10:50:48 +0900 KST'>2025. 1. 22.</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;770 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 등산코스 정하기(2022 KAKAO TECH INTERNSHIP)" href=https://leaf-nam.github.io/cote/programmers_118669/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 산 모양 타일링(2024 KAKAO WINTER INTERNSHIP)</h2></header><div class=entry-content><p>출처 2024 KAKAO WINTER INTERNSHIP 산 모양 타일링 접근 시간복잡도 구하기 n &lt;= 100,000 이므로 전체 타일의 개수는 최대 사다리꼴의 윗변의 모든 자리에 삼각형을 넣을 수 있으므로 2n + 1 + n &lt;= 300,001개 입니다.
이러한 삼각형의 배치를 완전탐색으로 구하는 것은 불가능하기 때문에, DP를 통한 최적화가 필요합니다.
규칙성 찾기 예제의 타일을 1칸씩 세면서 경우의 수를 세면 규칙성을 확인할 수 있습니다.
다음과 같이 (1 ~ 9) 순으로 예제타일의 규칙성을 구해보겠습니다.
...</p></div><footer class=entry-footer><span title='2025-01-07 13:47:29 +0900 KST'>2025. 1. 7.</span>&nbsp;·&nbsp;2 분&nbsp;·&nbsp;362 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 산 모양 타일링(2024 KAKAO WINTER INTERNSHIP)" href=https://leaf-nam.github.io/cote/programmers_258705/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Java]Programmers 멀쩡한 사각형</h2></header><div class=entry-content><p>출처 프로그래머스 멀쩡한 사각형 접근 규칙을 알고 나면 구하기 쉽지만, 모르면 생각보다 까다로운 문제입니다.
규칙 구하기 주어진 예시 (w = 8, h = 12)에 대해 규칙을 확인해보겠습니다.
문제의 예시를 자세히 보면 작은 사각형이 반복되는 것을 알 수 있습니다. w = 8과 h = 12의 최대공약수인 4개의 사각형이 생성됩니다.
즉, 최대공약수로 해당 길이를 나누었을 때 생성된 작은 사각형의 잘린 개수를 구하면 됩니다.
최대공약수로 나눠진 사각형(nw x nh = 2 x 3)의 잘린 개수는 다음과 같이 구할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-12-23 15:51:25 +0900 KST'>2024. 12. 23.</span>&nbsp;·&nbsp;3 분&nbsp;·&nbsp;442 단어&nbsp;·&nbsp;Leaf</footer><a class=entry-link aria-label="post link to [Java]Programmers 멀쩡한 사각형" href=https://leaf-nam.github.io/cote/programmers_62048/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://leaf-nam.github.io/tags/programmers/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://leaf-nam.github.io/tags/programmers/page/3/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://leaf-nam.github.io/>봄을 기다리는 낙엽</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>